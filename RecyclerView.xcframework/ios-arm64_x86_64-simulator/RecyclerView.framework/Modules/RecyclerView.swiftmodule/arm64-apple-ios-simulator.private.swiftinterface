// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
// swift-module-flags: -target arm64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name RecyclerView
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Foundation
import Swift
import UIKit.UIGestureRecognizerSubclass
import UIKit
import UniformTypeIdentifiers
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension RecyclerView.OrderedSet {
  @inlinable public init() {
    __storage = nil
    _elements = []
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public func contains(_ element: Element) -> Swift.Bool {
    _find_inlined(element).index != nil
  }
}
extension RecyclerView.OrderedSet {
  @discardableResult
  @inlinable public mutating func remove(_ member: Element) -> Element? {
    let (idx, bucket) = _find(member)
    guard let index = idx else { return nil }
    return _removeExistingMember(at: index, in: bucket)
  }
}
@usableFromInline
@frozen internal struct _UnsafeBitset {
  @usableFromInline
  internal let _words: Swift.UnsafeMutableBufferPointer<RecyclerView._UnsafeBitset.Word>
  @usableFromInline
  internal var _count: Swift.Int
  @inlinable @inline(__always) internal init(words: Swift.UnsafeMutableBufferPointer<RecyclerView._UnsafeBitset.Word>, count: Swift.Int) {
    self._words = words
    self._count = count
  }
  @inlinable @inline(__always) internal init(words: Swift.UnsafeMutablePointer<RecyclerView._UnsafeBitset.Word>, wordCount: Swift.Int, count: Swift.Int) {
    self._words = UnsafeMutableBufferPointer(start: words, count: wordCount)
    self._count = count
  }
  @inlinable @inline(__always) internal var count: Swift.Int {
    get {
    _count
  }
  }
}
extension RecyclerView._UnsafeBitset {
  @usableFromInline
  internal var _actualCount: Swift.Int {
    get
  }
}
extension RecyclerView._UnsafeBitset {
  @inlinable @inline(__always) internal static func withTemporaryBitset<R>(capacity: Swift.Int, run body: (inout RecyclerView._UnsafeBitset) throws -> R) rethrows -> R {
    var result: R?
    try _withTemporaryBitset(capacity: capacity) { bitset in
      result = try body(&bitset)
    }
    return result!
  }
  @usableFromInline
  @inline(never) internal static func _withTemporaryBitset(capacity: Swift.Int, run body: (inout RecyclerView._UnsafeBitset) throws -> Swift.Void) rethrows
}
extension RecyclerView._UnsafeBitset {
  @usableFromInline
  @_effects(readnone) @inline(__always) internal static func wordCount(forCapacity capacity: Swift.Int) -> Swift.Int
  @usableFromInline
  @discardableResult
  @_effects(releasenone) internal mutating func insert(_ element: Swift.Int) -> Swift.Bool
  @usableFromInline
  @discardableResult
  @_effects(releasenone) internal mutating func remove(_ element: Swift.Int) -> Swift.Bool
  @usableFromInline
  @_effects(releasenone) internal mutating func clear()
  @usableFromInline
  @_effects(releasenone) internal mutating func insertAll(upTo max: Swift.Int)
  @usableFromInline
  @_effects(releasenone) internal mutating func removeAll(upTo max: Swift.Int)
}
extension RecyclerView._UnsafeBitset : Swift.Sequence {
  @usableFromInline
  internal typealias Element = Swift.Int
  @inlinable @inline(__always) internal var underestimatedCount: Swift.Int {
    get {
    return count
  }
  }
  @inlinable @inline(__always) internal func makeIterator() -> RecyclerView._UnsafeBitset.Iterator {
    return Iterator(self)
  }
  @usableFromInline
  @frozen internal struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal let bitset: RecyclerView._UnsafeBitset
    @usableFromInline
    internal var index: Swift.Int
    @usableFromInline
    internal var word: RecyclerView._UnsafeBitset.Word
    @inlinable internal init(_ bitset: RecyclerView._UnsafeBitset) {
      self.bitset = bitset
      self.index = 0
      self.word = bitset._words.count > 0 ? bitset._words[0] : .empty
    }
    @usableFromInline
    @_effects(releasenone) internal mutating func next() -> Swift.Int?
    @usableFromInline
    internal typealias Element = Swift.Int
  }
}
extension RecyclerView._UnsafeBitset {
  @usableFromInline
  @frozen internal struct Word {
    @usableFromInline
    internal var value: Swift.UInt
    @inlinable @inline(__always) internal init(_ value: Swift.UInt) {
      self.value = value
    }
  }
}
extension RecyclerView._UnsafeBitset.Word {
  @inlinable @inline(__always) internal static var capacity: Swift.Int {
    get {
    return UInt.bitWidth
  }
  }
  @inlinable @inline(__always) internal var count: Swift.Int {
    get {
    value.nonzeroBitCount
  }
  }
  @inlinable @inline(__always) internal var isEmpty: Swift.Bool {
    get {
    value == 0
  }
  }
  @inlinable @inline(__always) internal func contains(_ bit: Swift.Int) -> Swift.Bool {
    assert(bit >= 0 && bit < UInt.bitWidth)
    return value & (1 &<< bit) != 0
  }
  @discardableResult
  @inlinable @inline(__always) internal mutating func insert(_ bit: Swift.Int) -> Swift.Bool {
    assert(bit >= 0 && bit < UInt.bitWidth)
    let mask: UInt = 1 &<< bit
    let inserted = value & mask == 0
    value |= mask
    return inserted
  }
  @discardableResult
  @inlinable @inline(__always) internal mutating func remove(_ bit: Swift.Int) -> Swift.Bool {
    assert(bit >= 0 && bit < UInt.bitWidth)
    let mask: UInt = 1 &<< bit
    let removed = value & mask != 0
    value &= ~mask
    return removed
  }
}
extension RecyclerView._UnsafeBitset.Word {
  @inlinable @inline(__always) internal mutating func insert(bitsBelow bit: Swift.Int) -> Swift.Int {
    assert(bit >= 0 && bit < Self.capacity)
    let mask: UInt = (1 as UInt &<< bit) &- 1
    let inserted = bit - (value & mask).nonzeroBitCount
    value |= mask
    return inserted
  }
  @inlinable @inline(__always) internal mutating func remove(bitsBelow bit: Swift.Int) -> Swift.Int {
    assert(bit >= 0 && bit < Self.capacity)
    let mask = UInt.max &<< bit
    let removed = (value & ~mask).nonzeroBitCount
    value &= mask
    return removed
  }
}
extension RecyclerView._UnsafeBitset.Word {
  @inlinable @inline(__always) internal static var empty: RecyclerView._UnsafeBitset.Word {
    get {
    Self(0)
  }
  }
  @inlinable @inline(__always) internal static var allBits: RecyclerView._UnsafeBitset.Word {
    get {
    Self(UInt.max)
  }
  }
}
extension RecyclerView._UnsafeBitset.Word : Swift.Sequence, Swift.IteratorProtocol {
  @inlinable internal var underestimatedCount: Swift.Int {
    get {
    count
  }
  }
  @inlinable internal mutating func next() -> Swift.Int? {
    guard value != 0 else { return nil }
    let bit = value.trailingZeroBitCount
    value &= value &- 1       // Clear lowest nonzero bit.
    return bit
  }
  @usableFromInline
  internal typealias Element = Swift.Int
  @usableFromInline
  internal typealias Iterator = RecyclerView._UnsafeBitset.Word
}
extension RecyclerView.OrderedDictionary : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (left: RecyclerView.OrderedDictionary<Key, Value>, right: RecyclerView.OrderedDictionary<Key, Value>) -> Swift.Bool {
    left._keys == right._keys && left._values == right._values
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol RecyclerViewEngine<Identifier, Payload> {
  associatedtype Identifier : Swift.Hashable
  associatedtype Payload : Swift.Equatable
  typealias Configuration = RecyclerView.CellConfiguration<Self.Payload>
  var identifiers: [Self.Identifier] { get }
  var contentSize: CoreFoundation.CGSize { get }
  func setup(_ coordinator: any RecyclerView.LayoutCoordinator<Self.Identifier, Self.Payload>, scrollView: RecyclerView.RecyclerScrollView<Self>)
  func prepare()
  func targetContentOffset(forProposedContentOffset proposedContentOffset: CoreFoundation.CGPoint, withScrollingVelocity velocity: CoreFoundation.CGPoint) -> CoreFoundation.CGPoint
  func payloadForIdentifier(_ identifier: Self.Identifier) -> Self.Payload?
  func updatePayload(_ payload: Self.Payload, forIdentifier identifier: Self.Identifier)
  func prepareLayoutSubviews()
  func applyModifications(_ actionStorage: RecyclerView.ModificationActionsStorage<Self.Identifier>, invalidationCoordinator: any RecyclerView.InvalidationCoordinator<Self.Identifier>)
  func beginLayoutIteration(invalidationCoordinator: any RecyclerView.InvalidationCoordinator<Self.Identifier>)
  func preferredConfiguration(for cellContext: any RecyclerView.CellContext<Self.Identifier>, invalidationCoordinator: any RecyclerView.InvalidationCoordinator<Self.Identifier>) -> Self.Configuration
  func finaliseLayoutIteration(invalidationCoordinator: any RecyclerView.InvalidationCoordinator<Self.Identifier>)
  func commitLayoutSubviews()
  func identifiersVisibleIn(_ rect: CoreFoundation.CGRect) -> [Self.Identifier]
  func identifierAtPoint(_ point: CoreFoundation.CGPoint) -> Self.Identifier?
  func configurationForIdentifier(_ identifier: Self.Identifier) -> Self.Configuration
  func configurationForAppearingItem(with identifier: Self.Identifier) -> Self.Configuration?
  func configurationDisappearingItem(with identifier: Self.Identifier) -> Self.Configuration?
}
#else
public protocol RecyclerViewEngine {
  associatedtype Identifier : Swift.Hashable
  associatedtype Payload : Swift.Equatable
  typealias Configuration = RecyclerView.CellConfiguration<Self.Payload>
  var identifiers: [Self.Identifier] { get }
  var contentSize: CoreFoundation.CGSize { get }
  func setup(_ coordinator: any RecyclerView.LayoutCoordinator<Self.Identifier, Self.Payload>, scrollView: RecyclerView.RecyclerScrollView<Self>)
  func prepare()
  func targetContentOffset(forProposedContentOffset proposedContentOffset: CoreFoundation.CGPoint, withScrollingVelocity velocity: CoreFoundation.CGPoint) -> CoreFoundation.CGPoint
  func payloadForIdentifier(_ identifier: Self.Identifier) -> Self.Payload?
  func updatePayload(_ payload: Self.Payload, forIdentifier identifier: Self.Identifier)
  func prepareLayoutSubviews()
  func applyModifications(_ actionStorage: RecyclerView.ModificationActionsStorage<Self.Identifier>, invalidationCoordinator: any RecyclerView.InvalidationCoordinator<Self.Identifier>)
  func beginLayoutIteration(invalidationCoordinator: any RecyclerView.InvalidationCoordinator<Self.Identifier>)
  func preferredConfiguration(for cellContext: any RecyclerView.CellContext<Self.Identifier>, invalidationCoordinator: any RecyclerView.InvalidationCoordinator<Self.Identifier>) -> Self.Configuration
  func finaliseLayoutIteration(invalidationCoordinator: any RecyclerView.InvalidationCoordinator<Self.Identifier>)
  func commitLayoutSubviews()
  func identifiersVisibleIn(_ rect: CoreFoundation.CGRect) -> [Self.Identifier]
  func identifierAtPoint(_ point: CoreFoundation.CGPoint) -> Self.Identifier?
  func configurationForIdentifier(_ identifier: Self.Identifier) -> Self.Configuration
  func configurationForAppearingItem(with identifier: Self.Identifier) -> Self.Configuration?
  func configurationDisappearingItem(with identifier: Self.Identifier) -> Self.Configuration?
}
#endif
public struct RecyclerViewCellState {
}
public protocol RecyclerViewCellEvenHandler : UIKit.UIView {
  func updateRecyclerItemConfiguration(identifier: some Any, payload: some Any)
}
extension RecyclerView.RecyclerViewCellEvenHandler {
  public func updateRecyclerItemConfiguration(identifier: some Any, payload: some Any)
}
extension RecyclerView.OrderedSet._UnstableInternals {
  @_spi(Testing) public var capacity: Swift.Int {
    get
  }
  @_spi(Testing) public var minimumCapacity: Swift.Int {
    get
  }
  @_spi(Testing) public var scale: Swift.Int {
    get
  }
  @_spi(Testing) public var reservedScale: Swift.Int {
    get
  }
  @_spi(Testing) public var bias: Swift.Int {
    get
  }
}
extension RecyclerView.OrderedSet {
  @_spi(Testing) @_alwaysEmitIntoClient public static var _minimumScale: Swift.Int {
    get {
    _HashTable.minimumScale
  }
  }
  @_spi(Testing) @_alwaysEmitIntoClient public static func _minimumCapacity(forScale scale: Swift.Int) -> Swift.Int {
    _HashTable.minimumCapacity(forScale: scale)
  }
  @_spi(Testing) @_alwaysEmitIntoClient public static func _maximumCapacity(forScale scale: Swift.Int) -> Swift.Int {
    _HashTable.maximumCapacity(forScale: scale)
  }
  @_spi(Testing) @_alwaysEmitIntoClient public static func _scale(forCapacity capacity: Swift.Int) -> Swift.Int {
    _HashTable.scale(forCapacity: capacity)
  }
  @_spi(Testing) @_alwaysEmitIntoClient public static func _biasRange(scale: Swift.Int) -> Swift.Range<Swift.Int> {
    guard scale != 0 else { return Range(uncheckedBounds: (0, 1)) }
    return Range(uncheckedBounds: (0, (1 &<< scale) - 1))
  }
}
extension RecyclerView.OrderedSet._UnstableInternals {
  @_spi(Testing) @_alwaysEmitIntoClient public var hasHashTable: Swift.Bool {
    get { base._table != nil }
  }
  @_spi(Testing) @_alwaysEmitIntoClient public var hashTableIdentity: Swift.ObjectIdentifier? {
    get {
    guard let storage = base.__storage else { return nil }
    return ObjectIdentifier(storage)
  }
  }
  @_spi(Testing) public var hashTableContents: [Swift.Int?] {
    get
  }
  @_spi(Testing) @_alwaysEmitIntoClient public mutating func _regenerateHashTable(bias: Swift.Int) {
    base._ensureUnique()
    let new = base._table!.copy()
    base._table!.read { source in
      new.update { target in
        target.bias = bias
        var it = source.bucketIterator(startingAt: _Bucket(offset: 0))
        repeat {
          target[it.currentBucket] = it.currentValue
          it.advance()
        } while it.currentBucket.offset != 0
      }
    }
    base._table = new
    base._checkInvariants()
  }
  @_spi(Testing) @_alwaysEmitIntoClient public mutating func reserveCapacity(_ minimumCapacity: Swift.Int, persistent: Swift.Bool) {
    base._reserveCapacity(minimumCapacity, persistent: persistent)
    base._checkInvariants()
  }
}
extension RecyclerView.OrderedSet {
  @_spi(Testing) public init<S>(_scale scale: Swift.Int, bias: Swift.Int, contents: S) where Element == S.Element, S : Swift.Sequence
}
extension RecyclerView.OrderedSet {
  @inlinable public init(minimumCapacity: Swift.Int, persistent: Swift.Bool = false) {
    self.init()
    self._reserveCapacity(minimumCapacity, persistent: persistent)
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
    self._reserveCapacity(minimumCapacity, persistent: false)
  }
}
extension RecyclerView.OrderedSet {
  @inlinable internal mutating func _reserveCapacity(_ minimumCapacity: Swift.Int, persistent: Swift.Bool) {
    precondition(minimumCapacity >= 0, "Minimum capacity cannot be negative")
    defer { _checkInvariants() }

    _elements.reserveCapacity(minimumCapacity)

    let currentScale = _scale
    let newScale = _HashTable.scale(forCapacity: minimumCapacity)

    let reservedScale = persistent ? newScale : _reservedScale

    if currentScale < newScale {
      // Grow the table.
      _regenerateHashTable(scale: newScale, reservedScale: reservedScale)
      return
    }

    let requiredScale = _HashTable.scale(forCapacity: self.count)
    let minScale = Swift.max(Swift.max(newScale, reservedScale), requiredScale)
    if minScale < currentScale {
      // Shrink the table.
      _regenerateHashTable(scale: minScale, reservedScale: reservedScale)
      return
    }

    // When we have the right size table, ensure it's unique and it has the
    // right persisted reservation.
    _ensureUnique()
    if _reservedScale != reservedScale {
      // Remember reserved scale.
      __storage!.header.reservedScale = reservedScale
    }
  }
}
public protocol ScrollViewRepresentation {
  var size: CoreFoundation.CGSize { get }
  var contentOffset: CoreFoundation.CGPoint { get }
  var contentSize: CoreFoundation.CGSize { get }
  var visibleRect: CoreFoundation.CGRect { get }
  var contentInset: UIKit.UIEdgeInsets { get }
  var adjustedContentInset: UIKit.UIEdgeInsets { get }
  var isDragging: Swift.Bool { get }
  var isDecelerating: Swift.Bool { get }
}
extension RecyclerView.ScrollViewRepresentation {
  public var isUserInitiatedScrolling: Swift.Bool {
    get
  }
  public var minContentOffset: CoreFoundation.CGPoint {
    get
  }
  public var maxContentOffset: CoreFoundation.CGPoint {
    get
  }
  public var bounds: CoreFoundation.CGRect {
    get
  }
}
public struct RecyclerViewDropProposal {
  public enum Intent : Swift.Hashable {
    case unspecified
    case insertAtDestination
    case insertIntoDestination
    public static func == (a: RecyclerView.RecyclerViewDropProposal.Intent, b: RecyclerView.RecyclerViewDropProposal.Intent) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var operation: UIKit.UIDropOperation
  public var intent: RecyclerView.RecyclerViewDropProposal.Intent
  public var proposedSize: CoreFoundation.CGSize?
  public init(operation: UIKit.UIDropOperation, intent: RecyclerView.RecyclerViewDropProposal.Intent, proposedSize: CoreFoundation.CGSize?)
}
public protocol DropInteractionSupportingEngine : RecyclerView.RecyclerViewEngine {
  func startDropSession(_ session: any UIKit.UIDropSession)
  func updateDropSession(_ session: any UIKit.UIDropSession, locationInView: CoreFoundation.CGPoint, proposal: RecyclerView.RecyclerViewDropProposal)
  func performDrop(_ session: any UIKit.UIDropSession)
  func finishDropSession(_ session: any UIKit.UIDropSession)
}
@_Concurrency.MainActor(unsafe) final public class DropInteraction<Engine> : ObjectiveC.NSObject, UIKit.UIInteraction, UIKit.UIDropInteractionDelegate where Engine : RecyclerView.DropInteractionSupportingEngine, Engine.Identifier == Swift.Int {
  @_Concurrency.MainActor(unsafe) @objc final public var view: UIKit.UIView? {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) public init(engine: Engine)
  @_Concurrency.MainActor(unsafe) @objc final public func willMove(to view: UIKit.UIView?)
  @_Concurrency.MainActor(unsafe) @objc final public func didMove(to view: UIKit.UIView?)
  @_Concurrency.MainActor(unsafe) @objc final public func dropInteraction(_ interaction: UIKit.UIDropInteraction, canHandle session: any UIKit.UIDropSession) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func dropInteraction(_ interaction: UIKit.UIDropInteraction, sessionDidEnter session: any UIKit.UIDropSession)
  @_Concurrency.MainActor(unsafe) @objc final public func dropInteraction(_ interaction: UIKit.UIDropInteraction, sessionDidUpdate session: any UIKit.UIDropSession) -> UIKit.UIDropProposal
  @_Concurrency.MainActor(unsafe) @objc final public func dropInteraction(_ interaction: UIKit.UIDropInteraction, sessionDidExit session: any UIKit.UIDropSession)
  @_Concurrency.MainActor(unsafe) @objc final public func dropInteraction(_ interaction: UIKit.UIDropInteraction, performDrop session: any UIKit.UIDropSession)
  @_Concurrency.MainActor(unsafe) @objc final public func dropInteraction(_ interaction: UIKit.UIDropInteraction, item: UIKit.UIDragItem, willAnimateDropWith animator: any UIKit.UIDragAnimating)
  @_Concurrency.MainActor(unsafe) @objc final public func dropInteraction(_ interaction: UIKit.UIDropInteraction, concludeDrop session: any UIKit.UIDropSession)
  @_Concurrency.MainActor(unsafe) @objc final public func dropInteraction(_ interaction: UIKit.UIDropInteraction, sessionDidEnd session: any UIKit.UIDropSession)
  @objc deinit
}
extension RecyclerView.OrderedDictionary {
  @inlinable public mutating func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
    _keys.swapAt(i, j)
    _values.swapAt(i, j)
  }
  @inlinable public mutating func partition(by belongsInSecondPartition: (RecyclerView.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows -> Swift.Int {
    let pivot = try _values.withUnsafeMutableBufferPointer { values in
      try _keys._partition(values: values, by: belongsInSecondPartition)
    }
    _checkInvariants()
    return pivot
  }
}
extension RecyclerView.OrderedDictionary {
  @inlinable public mutating func sort(by areInIncreasingOrder: (RecyclerView.OrderedDictionary<Key, Value>.Element, RecyclerView.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows {
    // FIXME: Implement in-place sorting.
    let temp = try self.sorted(by: areInIncreasingOrder)
    precondition(temp.count == self.count)
    temp.withUnsafeBufferPointer { source in
      _keys = OrderedSet(uncheckedUniqueElements: source.lazy.map { $0.key })
      _values = ContiguousArray(source.lazy.map { $0.value })
    }
    _checkInvariants()
  }
}
extension RecyclerView.OrderedDictionary where Key : Swift.Comparable {
  @inlinable public mutating func sort() {
    sort { $0.key < $1.key }
  }
}
extension RecyclerView.OrderedDictionary {
  @inlinable public mutating func shuffle() {
    var generator = SystemRandomNumberGenerator()
    shuffle(using: &generator)
  }
  @inlinable public mutating func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator {
    guard count > 1 else { return }
    var keys = self._keys.elements
    var values = self._values
    self = [:]
    var amount = keys.count
    var current = 0
    while amount > 1 {
      let random = Int.random(in: 0 ..< amount, using: &generator)
      amount -= 1
      keys.swapAt(current, current + random)
      values.swapAt(current, current + random)
      current += 1
    }
    self = OrderedDictionary(uncheckedUniqueKeys: keys, values: values)
  }
}
extension RecyclerView.OrderedDictionary {
  @inlinable public mutating func reverse() {
    _keys.reverse()
    _values.reverse()
  }
}
extension RecyclerView.OrderedDictionary : Swift.ExpressibleByDictionaryLiteral {
  @inlinable public init(dictionaryLiteral elements: (Key, Value)...) {
    self.init(uniqueKeysWithValues: elements)
  }
}
public struct ContinuousElement<Identifier> : Swift.Hashable where Identifier : Swift.Hashable {
  public var identifier: Identifier
  public var origin: CoreFoundation.CGFloat
  public var length: CoreFoundation.CGFloat
  public init(identifier: Identifier, origin: CoreFoundation.CGFloat, length: CoreFoundation.CGFloat)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RecyclerView.ContinuousElement<Identifier>, b: RecyclerView.ContinuousElement<Identifier>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RecyclerView.ContinuousElement {
  @inlinable @inline(__always) public var segment: RecyclerView.Segment {
    get {
        return Segment(origin: origin, length: length)
    }
  }
}
extension RecyclerView.OrderedSet : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension RecyclerView.OrderedDictionary : Swift.Hashable where Value : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(count) // Discriminator
    for (key, value) in self {
      hasher.combine(key)
      hasher.combine(value)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension RecyclerView.OrderedSet : Swift.Equatable {
  @inlinable public static func == (left: RecyclerView.OrderedSet<Element>, right: RecyclerView.OrderedSet<Element>) -> Swift.Bool {
    left.elementsEqual(right)
  }
}
public struct ItemModel<Identifier, Payload> where Identifier : Swift.Hashable, Payload : Swift.Equatable {
  public let identifier: Identifier
  public var configuration: RecyclerView.CellConfiguration<Payload>
  public init(identifier: Identifier, configuration: RecyclerView.CellConfiguration<Payload>)
  @inlinable @inline(__always) public var frame: CoreFoundation.CGRect {
    get {
            return configuration.frame
        }
    set {
            configuration.frame = newValue
        }
  }
  @inlinable @inline(__always) public var alpha: CoreFoundation.CGFloat {
    get {
            return configuration.alpha
        }
    set {
            configuration.alpha = newValue
        }
  }
  @inlinable @inline(__always) public var zIndex: Swift.Int {
    get {
            return configuration.zIndex
        }
    set {
            configuration.zIndex = newValue
        }
  }
  @inlinable @inline(__always) public var transform: CoreFoundation.CGAffineTransform {
    get {
            return configuration.transform
        }
    set {
            configuration.transform = newValue
        }
  }
  @inlinable @inline(__always) public var isHidden: Swift.Bool {
    get {
            return configuration.isHidden
        }
    set {
            configuration.isHidden = newValue
        }
  }
  @inlinable @inline(__always) public var payload: Payload {
    get {
            return configuration.payload
        }
    set {
            configuration.payload = newValue
        }
  }
  @inlinable @inline(__always) public var origin: CoreFoundation.CGPoint {
    get {
            frame.origin
        }
    set {
            frame.origin = newValue
        }
  }
  @inlinable @inline(__always) public var width: CoreFoundation.CGFloat {
    get {
            frame.width
        }
    set {
            frame.size.width = newValue
        }
  }
  @inlinable @inline(__always) public var height: CoreFoundation.CGFloat {
    get {
            frame.height
        }
    set {
            frame.size.height = newValue
        }
  }
}
public struct ItemPositionConfiguration<Identifier> : Swift.Hashable where Identifier : Swift.Hashable {
  public var identifier: Identifier
  public var offset: CoreFoundation.CGFloat
  public init(identifier: Identifier, offset: CoreFoundation.CGFloat)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RecyclerView.ItemPositionConfiguration<Identifier>, b: RecyclerView.ItemPositionConfiguration<Identifier>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RecyclerView.OrderedDictionary : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@usableFromInline
internal typealias _UnsafeHashTable = RecyclerView._HashTable.UnsafeHandle
extension RecyclerView._HashTable {
  @usableFromInline
  @frozen internal struct UnsafeHandle {
    @usableFromInline
    internal typealias Bucket = RecyclerView._HashTable.Bucket
    @usableFromInline
    internal var _header: Swift.UnsafeMutablePointer<RecyclerView._HashTable.Header>
    @usableFromInline
    internal var _buckets: Swift.UnsafeMutablePointer<Swift.UInt64>
    @inlinable @inline(__always) internal init(header: Swift.UnsafeMutablePointer<RecyclerView._HashTable.Header>, buckets: Swift.UnsafeMutablePointer<Swift.UInt64>, readonly: Swift.Bool) {
      self._header = header
      self._buckets = buckets
    }
    @inlinable @inline(__always) internal func assertMutable() {
    }
  }
}
extension RecyclerView._HashTable.UnsafeHandle {
  @inlinable @inline(__always) internal var scale: Swift.Int {
    get { _header.pointee.scale }
  }
  @inlinable @inline(__always) internal var reservedScale: Swift.Int {
    get { _header.pointee.reservedScale }
  }
  @inlinable @inline(__always) internal var seed: Swift.Int {
    get { _header.pointee.seed }
  }
  @inlinable @inline(__always) internal var bias: Swift.Int {
    get { _header.pointee.bias }
    nonmutating set { _header.pointee.bias = newValue }
  }
  @inlinable @inline(__always) internal var bucketCount: Swift.Int {
    get { 1 &<< scale }
  }
  @inlinable @inline(__always) internal var bucketMask: Swift.UInt64 {
    get { UInt64(truncatingIfNeeded: bucketCount) - 1 }
  }
  @inlinable @inline(__always) internal var bitCount: Swift.Int {
    get { scale &<< scale }
  }
  @inlinable @inline(__always) internal var wordCount: Swift.Int {
    get { (bitCount + UInt64.bitWidth - 1) / UInt64.bitWidth }
  }
  @inlinable @inline(__always) internal var capacity: Swift.Int {
    get { _HashTable.maximumCapacity(forScale: scale) }
  }
  @inlinable @inline(__always) internal func bucket(after bucket: RecyclerView._HashTable.UnsafeHandle.Bucket) -> RecyclerView._HashTable.UnsafeHandle.Bucket {
    var offset = bucket.offset + 1
    if offset == bucketCount {
      offset = 0
    }
    return Bucket(offset: offset)
  }
  @inlinable @inline(__always) internal func bucket(before bucket: RecyclerView._HashTable.UnsafeHandle.Bucket) -> RecyclerView._HashTable.UnsafeHandle.Bucket {
    let offset = (bucket.offset == 0 ? bucketCount : bucket.offset) - 1
    return Bucket(offset: offset)
  }
  @inlinable @inline(__always) internal func word(after word: Swift.Int) -> Swift.Int {
    var result = word + 1
    if result == wordCount {
      result = 0
    }
    return result
  }
  @inlinable @inline(__always) internal func word(before word: Swift.Int) -> Swift.Int {
    if word == 0 {
      return wordCount - 1
    }
    return word - 1
  }
  @inlinable internal func position(of bucket: RecyclerView._HashTable.UnsafeHandle.Bucket) -> (word: Swift.Int, bit: Swift.Int) {
    let start = bucket.offset &* scale
    return (start &>> 6, start & 0x3F)
  }
}
extension RecyclerView._HashTable.UnsafeHandle {
  @inlinable internal func _value(forBucketContents bucketContents: Swift.UInt64) -> Swift.Int? {
    let mask = bucketMask
    assert(bucketContents <= mask)
    guard bucketContents != 0 else { return nil }
    let v = (bucketContents ^ mask) &+ UInt64(truncatingIfNeeded: bias)
    return Int(truncatingIfNeeded: v >= mask ? v - mask : v)
  }
  @inlinable internal func _bucketContents(for value: Swift.Int?) -> Swift.UInt64 {
    guard var value = value else { return 0 }
    let mask = Int(truncatingIfNeeded: bucketMask)
    assert(value >= 0 && value < mask)
    value &-= bias
    if value < 0 { value += mask }
    assert(value >= 0 && value < mask)
    return UInt64(truncatingIfNeeded: value ^ mask)
  }
  @inlinable internal subscript(word word: Swift.Int) -> Swift.UInt64 {
    @inline(__always) get {
      assert(word >= 0 && word < bucketCount)
      return _buckets[word]
    }
    @inline(__always) nonmutating set {
      assert(word >= 0 && word < bucketCount)
      assertMutable()
      _buckets[word] = newValue
    }
  }
  @inlinable internal subscript(raw bucket: RecyclerView._HashTable.UnsafeHandle.Bucket) -> Swift.UInt64 {
    get {
      assert(bucket.offset < bucketCount)
      let (word, bit) = position(of: bucket)
      var value = self[word: word] &>> bit
      let extractedBits = 64 - bit
      if extractedBits < scale {
        let word2 = self.word(after: word)
        value &= (1 &<< extractedBits) - 1
        value |= self[word: word2] &<< extractedBits
      }
      return value & bucketMask
    }
    nonmutating set {
      assertMutable()
      assert(bucket.offset < bucketCount)
      let mask = bucketMask
      assert(newValue <= mask)
      let (word, bit) = position(of: bucket)
      self[word: word] &= ~(mask &<< bit)
      self[word: word] |= newValue &<< bit
      let extractedBits = 64 - bit
      if extractedBits < scale {
        let word2 = self.word(after: word)
        self[word: word2] &= ~((1 &<< (scale - extractedBits)) - 1)
        self[word: word2] |= newValue &>> extractedBits
      }
    }
  }
  @inlinable @inline(__always) internal func isOccupied(_ bucket: RecyclerView._HashTable.UnsafeHandle.Bucket) -> Swift.Bool {
    self[raw: bucket] != 0
  }
  @inlinable internal subscript(bucket: RecyclerView._HashTable.UnsafeHandle.Bucket) -> Swift.Int? {
    get {
      let contents = self[raw: bucket]
      return _value(forBucketContents: contents)
    }
    nonmutating set {
      assertMutable()
      let v = _bucketContents(for: newValue)
      self[raw: bucket] = v
    }
  }
}
extension RecyclerView._HashTable.UnsafeHandle {
  @inlinable internal func _find<Base>(_ item: Base.Element, in elements: Base) -> (index: Swift.Int?, bucket: RecyclerView._HashTable.UnsafeHandle.Bucket) where Base : Swift.RandomAccessCollection, Base.Element : Swift.Hashable {
    let start = idealBucket(for: item)
    var (iterator, value) = startFind(start)
    while let index = value {
      if elements[_offset: index] == item {
        return (index, iterator.currentBucket)
      }
      value = iterator.findNext()
    }
    return (nil, iterator.currentBucket)
  }
}
extension RecyclerView._HashTable.UnsafeHandle {
  @usableFromInline
  internal func firstOccupiedBucketInChain(with bucket: RecyclerView._HashTable.UnsafeHandle.Bucket) -> RecyclerView._HashTable.UnsafeHandle.Bucket
  @inlinable internal func delete(bucket: RecyclerView._HashTable.UnsafeHandle.Bucket, hashValueGenerator: (Swift.Int, Swift.Int) -> Swift.Int) {
    assertMutable()
    var it = bucketIterator(startingAt: bucket)
    assert(it.isOccupied)
    it.advance()
    guard it.isOccupied else {
      // Fast path: Don't get the start bucket when there's nothing to do.
      self[bucket] = nil
      return
    }
    // If we've put a hole in the middle of a collision chain, some element after
    // the hole may belong where the new hole is.

    // Find the first bucket in the collision chain that contains the entry we've just deleted.
    let start = firstOccupiedBucketInChain(with: bucket)
    var hole = bucket

    while it.isOccupied {
      let hash = hashValueGenerator(it.currentValue!, seed)
      let candidate = idealBucket(forHashValue: hash)

      // Does this element belong between start and hole?  We need two
      // separate tests depending on whether [start, hole] wraps around the
      // end of the storage.
      let c0 = candidate.offset >= start.offset
      let c1 = candidate.offset <= hole.offset
      if start.offset <= hole.offset ? (c0 && c1) : (c0 || c1) {
        // Fill the hole. Here we are mutating table contents behind the back of
        // the iterator; this is okay since we know we are never going to revisit
        // `hole` with it.
        self[hole] = it.currentValue
        hole = it.currentBucket
      }
      it.advance()
    }
    self[hole] = nil
  }
}
extension RecyclerView._HashTable.UnsafeHandle {
  @inlinable internal func adjustContents<Base>(preparingForInsertionOfElementAtOffset offset: Swift.Int, in elements: Base) where Base : Swift.RandomAccessCollection, Base.Element : Swift.Hashable {
    assertMutable()
    let index = elements._index(at: offset)
    if offset < elements.count / 2 {
      self.bias += 1
      if offset <= capacity / 3 {
        var i = 1
        for item in elements[..<index] {
          var it = bucketIterator(for: item)
          it.advance(until: i)
          it.currentValue! -= 1
          i += 1
        }
      } else {
        var it = bucketIterator(startingAt: Bucket(offset: 0))
        repeat {
          if let value = it.currentValue, value <= offset {
            it.currentValue = value - 1
          }
          it.advance()
        } while it.currentBucket.offset != 0
      }
    } else {
      if elements.count - offset - 1 <= capacity / 3 {
        var i = offset
        for item in elements[index...] {
          var it = bucketIterator(for: item)
          it.advance(until: i)
          it.currentValue! += 1
          i += 1
        }
      } else {
        var it = bucketIterator(startingAt: Bucket(offset: 0))
        repeat {
          if let value = it.currentValue, value >= offset {
            it.currentValue = value + 1
          }
          it.advance()
        } while it.currentBucket.offset != 0
      }
    }
  }
}
extension RecyclerView._HashTable.UnsafeHandle {
  @inlinable @inline(__always) internal func adjustContents<Base>(preparingForRemovalOf index: Base.Index, in elements: Base) where Base : Swift.RandomAccessCollection, Base.Element : Swift.Hashable {
    let next = elements.index(after: index)
    adjustContents(preparingForRemovalOf: index ..< next, in: elements)
  }
  @inlinable internal func adjustContents<Base>(preparingForRemovalOf bounds: Swift.Range<Base.Index>, in elements: Base) where Base : Swift.RandomAccessCollection, Base.Element : Swift.Hashable {
    assertMutable()
    let startOffset = elements._offset(of: bounds.lowerBound)
    let endOffset = elements._offset(of: bounds.upperBound)
    let c = endOffset - startOffset
    guard c > 0 else { return }
    let remainingCount = elements.count - c

    if startOffset >= remainingCount / 2 {
      let tailCount = elements.count - endOffset
      if tailCount < capacity / 3 {
        var i = endOffset
        for item in elements[bounds.upperBound...] {
          var it = self.bucketIterator(for: item)
          it.advance(until: i)
          it.currentValue = i - c
          i += 1
        }
      } else {
        var it = bucketIterator(startingAt: Bucket(offset: 0))
        repeat {
          if let value = it.currentValue {
            if value >= endOffset {
              it.currentValue = value - c
            } else {
              assert(value < startOffset)
            }
          }
          it.advance()
        } while it.currentBucket.offset != 0
      }
    } else {
      if startOffset < capacity / 3 {
        var i = 0
        for item in elements[..<bounds.lowerBound] {
          var it = self.bucketIterator(for: item)
          it.advance(until: i)
          it.currentValue = i + c
          i += 1
        }
      } else {
        var it = bucketIterator(startingAt: Bucket(offset: 0))
        repeat {
          if let value = it.currentValue {
            if value < startOffset {
              it.currentValue = value + c
            } else {
              assert(value >= endOffset)
            }
          }
          it.advance()
        } while it.currentBucket.offset != 0
      }
      self.bias -= c
    }
  }
}
extension RecyclerView._HashTable.UnsafeHandle {
  @usableFromInline
  internal func clear()
}
extension RecyclerView._HashTable.UnsafeHandle {
  @inlinable internal func fill<C>(uncheckedUniqueElements elements: C) where C : Swift.RandomAccessCollection, C.Element : Swift.Hashable {
    assertMutable()
    assert(elements.count <= capacity)
    // Iterate over elements and insert their offset into the hash table.
    var offset = 0
    for index in elements.indices {
      // Find the insertion position. We know that we're inserting a new item,
      // so there is no need to compare it with any of the existing ones.
      var it = bucketIterator(for: elements[index])
      it.advanceToNextUnoccupiedBucket()
      it.currentValue = offset
      offset += 1
    }
  }
  @inlinable internal func fill<C>(untilFirstDuplicateIn elements: C) -> (success: Swift.Bool, end: C.Index) where C : Swift.RandomAccessCollection, C.Element : Swift.Hashable {
    assertMutable()
    assert(elements.count <= capacity)
    // Iterate over elements and insert their offset into the hash table.
    var offset = 0
    for index in elements.indices {
      // Find the insertion position. We know that we're inserting a new item,
      // so there is no need to compare it with any of the existing ones.
      var it = bucketIterator(for: elements[index])
      while let offset = it.currentValue {
        guard elements[_offset: offset] != elements[index] else {
          return (false, index)
        }
        it.advance()
      }
      it.currentValue = offset
      offset += 1
    }
    return (true, elements.endIndex)
  }
}
@inlinable @inline(__always) public func fitToScale(_ value: CoreFoundation.CGFloat, scale: CoreFoundation.CGFloat = 1) -> CoreFoundation.CGFloat {
    let roundedValue = round(value * scale) / scale
    return roundedValue
}
@_hasMissingDesignatedInitializers final public class ContinuousLayoutModel<Identifier> where Identifier : Swift.Hashable {
  public typealias Element = RecyclerView.ContinuousElement<Identifier>
  final public var contentHeight: CoreFoundation.CGFloat {
    get
  }
  final public var exactSegment: RecyclerView.Segment {
    get
    set
  }
  public init()
  final public func getAllIdentifiers() -> RecyclerView.OrderedSet<Identifier>
  final public func getExactIdentifiers() -> [Identifier]
  final public func getAllExactElements() -> [RecyclerView.ContinuousLayoutModel<Identifier>.Element]
  final public func getAllElements() -> [RecyclerView.ContinuousLayoutModel<Identifier>.Element]
  final public func indexForIdentifier(_ identifier: Identifier) -> Swift.Int?
  final public subscript(identifier: Identifier) -> RecyclerView.ContinuousLayoutModel<Identifier>.Element {
    get
  }
  final public func elementWithIdentifier(_ identifier: Identifier) -> RecyclerView.ContinuousLayoutModel<Identifier>.Element?
  final public func insertElementWithIdentifier(_ identifier: __owned Identifier, length: CoreFoundation.CGFloat, at index: Swift.Int)
  final public func removeElementWithIdentifier(_ identifier: Identifier)
  final public func updateLengthForIdentifier(_ identifier: Identifier, length newLength: CoreFoundation.CGFloat)
  final public func moveElementWithIdentifier(_ identifier: Identifier, to index: Swift.Int)
  final public func normaliseIfNeeded()
  final public func copy() -> RecyclerView.ContinuousLayoutModel<Identifier>
  @objc deinit
}
extension RecyclerView.OrderedSet {
  @inlinable internal mutating func _appendNew(_ item: Element) {
    assert(!contains(item), "Duplicate item")
    _elements.append(item)
    guard _elements.count <= _capacity else {
      _regenerateHashTable()
      return
    }
    guard _table != nil else { return }
    _ensureUnique()
    _table!.update { hashTable in
      var it = hashTable.bucketIterator(for: item)
      it.advanceToNextUnoccupiedBucket()
      it.currentValue = _elements.count - 1
    }
  }
  @inlinable internal mutating func _appendNew(_ item: Element, in bucket: RecyclerView.OrderedSet<Element>._Bucket) {
    _elements.append(item)

    guard _elements.count <= _capacity else {
      _regenerateHashTable()
      return
    }
    guard _table != nil else { return }
    _ensureUnique()
    _table!.update { hashTable in
      assert(!hashTable.isOccupied(bucket))
      hashTable[bucket] = _elements.count - 1
    }
  }
  @discardableResult
  @inlinable internal mutating func _append(_ item: Element) -> (inserted: Swift.Bool, index: Swift.Int) {
    let (index, bucket) = _find(item)
    if let index = index { return (false, index) }
    _appendNew(item, in: bucket)
    return (true, _elements.index(before: _elements.endIndex))
  }
  @discardableResult
  @inlinable @inline(__always) public mutating func append(_ item: Element) -> (inserted: Swift.Bool, index: Swift.Int) {
    let result = _append(item)
    _checkInvariants()
    return result
  }
  @inlinable public mutating func append<S>(contentsOf elements: S) where Element == S.Element, S : Swift.Sequence {
    for item in elements {
      _append(item)
    }
    _checkInvariants()
  }
}
extension RecyclerView.OrderedSet {
  @inlinable internal mutating func _insertNew(_ item: Element, at index: Swift.Int, in bucket: RecyclerView.OrderedSet<Element>._Bucket) {
    guard _elements.count < _capacity else {
      _elements.insert(item, at: index)
      _regenerateHashTable()
      return
    }
    guard _table != nil else {
      _elements.insert(item, at: index)
      return
    }

    _ensureUnique()
    _table!.update { hashTable in
      assert(!hashTable.isOccupied(bucket))
      hashTable.adjustContents(preparingForInsertionOfElementAtOffset: index, in: _elements)
      hashTable[bucket] = index
    }
    _elements.insert(item, at: index)
    _checkInvariants()
  }
  @discardableResult
  @inlinable public mutating func insert(_ item: Element, at index: Swift.Int) -> (inserted: Swift.Bool, index: Swift.Int) {
    let (existing, bucket) = _find(item)
    if let existing = existing { return (false, existing) }
    _insertNew(item, at: index, in: bucket)
    return (true, index)
  }
}
extension RecyclerView.OrderedSet {
  @discardableResult
  @inlinable public mutating func update(_ item: Element, at index: Swift.Int) -> Element {
    let old = _elements[index]
    precondition(
      item == old,
      "The replacement item must compare equal to the original")
    _elements[index] = item
    return old
  }
}
extension RecyclerView.OrderedSet {
  @discardableResult
  @inlinable public mutating func updateOrAppend(_ item: Element) -> Element? {
    let (inserted, index) = _append(item)
    if inserted { return nil }
    let old = _elements[index]
    _elements[index] = item
    _checkInvariants()
    return old
  }
  @discardableResult
  @inlinable public mutating func updateOrInsert(_ item: Element, at index: Swift.Int) -> (originalMember: Element?, index: Swift.Int) {
    let (existing, bucket) = _find(item)
    if let existing = existing {
      let old = _elements[existing]
      _elements[existing] = item
      return (old, existing)
    }
    _insertNew(item, at: index, in: bucket)
    return (nil, index)
  }
}
extension RecyclerView.OrderedSet : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(count) // Discriminator
    for item in _elements {
      hasher.combine(item)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
@frozen public struct OrderedDictionary<Key, Value> where Key : Swift.Hashable {
  @usableFromInline
  internal var _keys: RecyclerView.OrderedSet<Key>
  @usableFromInline
  internal var _values: Swift.ContiguousArray<Value>
  @inlinable @inline(__always) internal init(_uniqueKeys keys: RecyclerView.OrderedSet<Key>, values: Swift.ContiguousArray<Value>) {
    self._keys = keys
    self._values = values
  }
}
extension RecyclerView.OrderedDictionary {
  @inlinable @inline(__always) public var keys: RecyclerView.OrderedSet<Key> {
    get { _keys }
  }
  @inlinable @inline(__always) public var values: RecyclerView.OrderedDictionary<Key, Value>.Values {
    get { Values(_base: self) }
    @inline(__always) _modify {
      var values = Values(_base: self)
      self = [:]
      defer { self = values._base }
      yield &values
    }
  }
}
extension RecyclerView.OrderedDictionary {
  public typealias Index = Swift.Int
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _values.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _values.count }
  }
  @inlinable @inline(__always) public func index(forKey key: Key) -> Swift.Int? {
    _keys.firstIndex(of: key)
  }
}
extension RecyclerView.OrderedDictionary {
  @inlinable public subscript(key: Key) -> Value? {
    get {
      guard let index = _keys.firstIndex(of: key) else { return nil }
      return _values[index]
    }
    set {
      // We have a separate `set` in addition to `_modify` in hopes of getting
      // rid of `_modify`'s swapAt dance in the usual case where the caller just
      // wants to assign a new value.
      let (index, bucket) = _keys._find(key)
      switch (index, newValue) {
      case let (index?, newValue?): // Assign
        _values[index] = newValue
      case let (index?, nil): // Remove
        _keys._removeExistingMember(at: index, in: bucket)
        _values.remove(at: index)
      case let (nil, newValue?): // Insert
        _keys._appendNew(key, in: bucket)
        _values.append(newValue)
      case (nil, nil): // Noop
        break
      }
      _checkInvariants()
    }
    @inline(__always) _modify {
      var value: Value?
      let (index, bucket) = _prepareForKeyingModify(key, &value)
      defer {
        _finalizeKeyingModify(key, index, bucket, &value)
      }
      yield &value
    }
  }
  @inlinable internal mutating func _prepareForKeyingModify(_ key: Key, _ value: inout Value?) -> (index: Swift.Int?, bucket: RecyclerView._HashTable.Bucket) {
    let (index, bucket) = _keys._find(key)

    // To support in-place mutations better, we swap the value to the end of
    // the array, pop it off, then put things back in place when we're done.
    if let index = index {
      _values.swapAt(index, _values.count - 1)
      value = _values.removeLast()
    }
    return (index, bucket)
  }
  @inlinable internal mutating func _finalizeKeyingModify(_ key: Key, _ index: Swift.Int?, _ bucket: RecyclerView._HashTable.Bucket, _ value: inout Value?) {
    switch (index, value) {
    case let (index?, value?): // Assign
      _values.append(value)
      _values.swapAt(index, _values.count - 1)
    case let (index?, nil): // Remove
      if index < _values.count {
        let standin = _values.remove(at: index)
        _values.append(standin)
      }
      _keys._removeExistingMember(at: index, in: bucket)
    case let (nil, value?): // Insert
      _keys._appendNew(key, in: bucket)
      _values.append(value)
    case (nil, nil): // Noop
      break
    }
    _checkInvariants()
  }
  @inlinable public subscript(key: Key, default defaultValue: @autoclosure () -> Value) -> Value {
    get {
      guard let offset = _keys.firstIndex(of: key) else { return defaultValue() }
      return _values[offset]
    }
    @inline(__always) _modify {
      var (index, value) = _prepareForDefaultedModify(key, defaultValue)
      defer {
        _finalizeDefaultedModify(index, &value)
      }
      yield &value
    }
  }
  @inlinable internal mutating func _prepareForDefaultedModify(_ key: Key, _ defaultValue: () -> Value) -> (index: Swift.Int, value: Value) {
    let (inserted, index) = _keys.append(key)
    if inserted {
      assert(index == _values.count)
      _values.append(defaultValue())
    }
    let value: Value = _values.withUnsafeMutableBufferPointer { buffer in
      assert(index < buffer.count)
      return (buffer.baseAddress! + index).move()
    }
    return (index, value)
  }
  @inlinable internal mutating func _finalizeDefaultedModify(_ index: Swift.Int, _ value: inout Value) {
    _values.withUnsafeMutableBufferPointer { buffer in
      assert(index < buffer.count)
      (buffer.baseAddress! + index).initialize(to: value)
    }
  }
}
extension RecyclerView.OrderedDictionary {
  @discardableResult
  @inlinable public mutating func updateValue(_ value: Value, forKey key: Key) -> Value? {
    let (index, bucket) = _keys._find(key)
    if let index = index {
      let old = _values[index]
      _values[index] = value
      return old
    }
    _keys._appendNew(key, in: bucket)
    _values.append(value)
    return nil
  }
  @discardableResult
  @inlinable public mutating func updateValue(_ value: Value, forKey key: Key, insertingAt index: Swift.Int) -> (originalMember: Value?, index: Swift.Int) {
    let (inserted, offset) = _keys.insert(key, at: index)
    if inserted {
      assert(offset == index)
      _values.insert(value, at: offset)
      return (nil, offset)
    }
    let old = _values[offset]
    _values[offset] = value
    return (old, offset)
  }
  @inlinable public mutating func updateValue<R>(forKey key: Key, default defaultValue: @autoclosure () -> Value, with body: (inout Value) throws -> R) rethrows -> R {
    let (index, bucket) = _keys._find(key)
    if let index = index {
      return try body(&_values[index])
    }
    _keys._appendNew(key, in: bucket)
    _values.append(defaultValue())
    let i = _values.index(before: _values.endIndex)
    return try body(&_values[i])
  }
  @inlinable public mutating func updateValue<R>(forKey key: Key, insertingDefault defaultValue: @autoclosure () -> Value, at index: Swift.Int, with body: (inout Value) throws -> R) rethrows -> R {
    let (existingIndex, bucket) = _keys._find(key)
    if let existingIndex = existingIndex {
      return try body(&_values[existingIndex])
    }
    _keys._insertNew(key, at: index, in: bucket)
    _values.insert(defaultValue(), at: index)
    return try body(&_values[index])
  }
}
extension RecyclerView.OrderedDictionary {
  @discardableResult
  @inlinable public mutating func removeValue(forKey key: Key) -> Value? {
    let (idx, bucket) = _keys._find(key)
    guard let index = idx else { return nil }
    _keys._removeExistingMember(at: index, in: bucket)
    return _values.remove(at: index)
  }
}
extension RecyclerView.OrderedDictionary {
  @_disfavoredOverload @inlinable public mutating func merge<S>(_ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
    for (key, value) in keysAndValues {
      let (index, bucket) = _keys._find(key)
      if let index = index {
        try { $0 = try combine($0, value) }(&_values[index])
      } else {
        _keys._appendNew(key, in: bucket)
        _values.append(value)
      }
    }
  }
  @inlinable public mutating func merge<S>(_ keysAndValues: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    let mapped: LazyMapSequence =
      keysAndValues.lazy.map { (key: $0.0, value: $0.1) }
    try merge(mapped, uniquingKeysWith: combine)
  }
  @_disfavoredOverload @inlinable public __consuming func merging<S>(_ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> RecyclerView.OrderedDictionary<Key, Value> where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
    var copy = self
    try copy.merge(other, uniquingKeysWith: combine)
    return copy
  }
  @inlinable public __consuming func merging<S>(_ other: __owned S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows -> RecyclerView.OrderedDictionary<Key, Value> where S : Swift.Sequence, S.Element == (Key, Value) {
    var copy = self
    try copy.merge(other, uniquingKeysWith: combine)
    return copy
  }
}
extension RecyclerView.OrderedDictionary {
  @inlinable public func filter(_ isIncluded: (RecyclerView.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows -> RecyclerView.OrderedDictionary<Key, Value> {
    var result: OrderedDictionary = [:]
    for element in self where try isIncluded(element) {
      result._keys._appendNew(element.key)
      result._values.append(element.value)
    }
    return result
  }
}
extension RecyclerView.OrderedDictionary {
  @inlinable public func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> RecyclerView.OrderedDictionary<Key, T> {
    OrderedDictionary<Key, T>(
      _uniqueKeys: _keys,
      values: ContiguousArray(try _values.map(transform)))
  }
  @inlinable public func compactMapValues<T>(_ transform: (Value) throws -> T?) rethrows -> RecyclerView.OrderedDictionary<Key, T> {
    var result: OrderedDictionary<Key, T> = [:]
    for (key, value) in self {
      if let value = try transform(value) {
        result._keys._appendNew(key)
        result._values.append(value)
      }
    }
    return result
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    _elements.removeAll(keepingCapacity: keepCapacity)
    guard keepCapacity else {
      _table = nil
      return
    }
    guard _table != nil else { return }
    _ensureUnique()
    _table!.update { hashTable in
      hashTable.clear()
    }
  }
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Int) -> RecyclerView.OrderedSet<Element>.Element {
    _elements._failEarlyRangeCheck(index, bounds: startIndex ..< endIndex)
    let bucket = _bucket(for: index)
    return _removeExistingMember(at: index, in: bucket)
  }
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Int>) {
    _elements._failEarlyRangeCheck(
      bounds,
      bounds: _elements.startIndex ..< _elements.endIndex)
    guard _table != nil else {
      _elements.removeSubrange(bounds)
      _checkInvariants()
      return
    }
    let c = bounds.count
    guard c > 0 else { return }
    let remainingCount = _elements.count - c
    if remainingCount <= count / 2 || remainingCount < _minimumCapacity {
      // Just generate a new table from scratch.
      _elements.removeSubrange(bounds)
      _regenerateHashTable()
      _checkInvariants()
      return
    }

    _ensureUnique()
    _table!.update { hashTable in
      // Delete the hash table entries for all members we're removing.
      for item in _elements[bounds] {
        let (offset, bucket) = hashTable._find(item, in: _elements)
        precondition(offset != nil, "Corrupt hash table")
        hashTable.delete(
          bucket: bucket,
          hashValueGenerator: { offset, seed in
            return _elements[offset]._rawHashValue(seed: seed)
          })
      }
      hashTable.adjustContents(preparingForRemovalOf: bounds, in: _elements)
    }
    _elements.removeSubrange(bounds)
    _checkInvariants()
  }
  @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : Swift.RangeExpression, R.Bound == Swift.Int {
    removeSubrange(bounds.relative(to: self))
  }
  @discardableResult
  @inlinable public mutating func removeLast() -> Element {
    precondition(!isEmpty, "Cannot remove last element of an empty collection")
    guard _table != nil else {
      return _elements.removeLast()
    }
    guard _elements.count - 1 >= _minimumCapacity else {
      let old = _elements.removeLast()
      _regenerateHashTable()
      return old
    }
    defer { _checkInvariants() }
    let old = _elements.removeLast()
    _ensureUnique()
    _table!.update { hashTable in
      var it = hashTable.bucketIterator(for: old)
      it.advance(until: _elements.count)
      // Delete the entry for the removed member.
      hashTable.delete(
        bucket: it.currentBucket,
        hashValueGenerator: { offset, seed in
          _elements[offset]._rawHashValue(seed: seed)
        })
    }
    return old
  }
  @inlinable public mutating func removeLast(_ n: Swift.Int) {
    precondition(n >= 0, "Can't remove a negative number of elements")
    precondition(n <= count, "Can't remove more elements than there are in the collection")
    removeSubrange(count - n ..< count)
  }
  @discardableResult
  @inlinable public mutating func removeFirst() -> Element {
    precondition(!isEmpty, "Cannot remove first element of an empty collection")
    return remove(at: startIndex)
  }
  @inlinable public mutating func removeFirst(_ n: Swift.Int) {
    precondition(n >= 0, "Can't remove a negative number of elements")
    precondition(n <= count, "Can't remove more elements than there are in the collection")
    removeSubrange(0 ..< n)
  }
  @inlinable public mutating func removeAll(where shouldBeRemoved: (Element) throws -> Swift.Bool) rethrows {
    defer {
      _regenerateHashTable()
      _checkInvariants()
    }
    try _elements.removeAll(where: shouldBeRemoved)
  }
}
extension RecyclerView.SimpleLayoutEngine {
  public struct PositionSnapshot : Swift.Hashable {
    public enum Edge : Swift.Hashable {
      case top
      case bottom
      public static func == (a: RecyclerView.SimpleLayoutEngine<Identifier, Payload>.PositionSnapshot.Edge, b: RecyclerView.SimpleLayoutEngine<Identifier, Payload>.PositionSnapshot.Edge) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public var identifier: Identifier
    public var edge: RecyclerView.SimpleLayoutEngine<Identifier, Payload>.PositionSnapshot.Edge
    public var offset: CoreFoundation.CGFloat
    public init(identifier: Identifier, edge: RecyclerView.SimpleLayoutEngine<Identifier, Payload>.PositionSnapshot.Edge, offset: CoreFoundation.CGFloat = 0)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: RecyclerView.SimpleLayoutEngine<Identifier, Payload>.PositionSnapshot, b: RecyclerView.SimpleLayoutEngine<Identifier, Payload>.PositionSnapshot) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public mutating func formUnion(_ other: __owned RecyclerView.OrderedSet<Element>) {
    append(contentsOf: other)
  }
  @inlinable public __consuming func union(_ other: __owned RecyclerView.OrderedSet<Element>) -> RecyclerView.OrderedSet<Element> {
    var result = self
    result.formUnion(other)
    return result
  }
  @inlinable @inline(__always) public mutating func formUnion(_ other: __owned RecyclerView.OrderedSet<Element>.UnorderedView) {
    formUnion(other._base)
  }
  @inlinable @inline(__always) public __consuming func union(_ other: __owned RecyclerView.OrderedSet<Element>.UnorderedView) -> RecyclerView.OrderedSet<Element> {
    union(other._base)
  }
  @inlinable public mutating func formUnion<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
    append(contentsOf: other)
  }
  @inlinable public __consuming func union<S>(_ other: __owned S) -> RecyclerView.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
    var result = self
    result.formUnion(other)
    return result
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public __consuming func intersection(_ other: RecyclerView.OrderedSet<Element>) -> RecyclerView.OrderedSet<Element> {
    var result = Self()
    for item in self {
      if other.contains(item) {
        result._appendNew(item)
      }
    }
    result._checkInvariants()
    return result
  }
  @inlinable public mutating func formIntersection(_ other: RecyclerView.OrderedSet<Element>) {
    self = self.intersection(other)
  }
  @inlinable @inline(__always) public __consuming func intersection(_ other: RecyclerView.OrderedSet<Element>.UnorderedView) -> RecyclerView.OrderedSet<Element> {
    intersection(other._base)
  }
  @inlinable @inline(__always) public mutating func formIntersection(_ other: RecyclerView.OrderedSet<Element>.UnorderedView) {
    formIntersection(other._base)
  }
  @inlinable public __consuming func intersection<S>(_ other: S) -> RecyclerView.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
    _UnsafeBitset.withTemporaryBitset(capacity: self.count) { bitset in
      for item in other {
        if let index = self._find_inlined(item).index {
          bitset.insert(index)
        }
      }
      let result = self._extractSubset(using: bitset)
      result._checkInvariants()
      return result
    }
  }
  @inlinable public mutating func formIntersection<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
    self = self.intersection(other)
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public __consuming func symmetricDifference(_ other: __owned RecyclerView.OrderedSet<Element>) -> RecyclerView.OrderedSet<Element> {
    _UnsafeBitset.withTemporaryBitset(capacity: self.count) { bitset1 in
      _UnsafeBitset.withTemporaryBitset(capacity: other.count) { bitset2 in
        bitset1.insertAll(upTo: self.count)
        for item in other {
          if let index = self._find(item).index {
            bitset1.remove(index)
          }
        }
        bitset2.insertAll(upTo: other.count)
        for item in self {
          if let index = other._find(item).index {
            bitset2.remove(index)
          }
        }
        var result = self._extractSubset(using: bitset1,
                                         extraCapacity: bitset2.count)
        for offset in bitset2 {
          result._appendNew(other._elements[offset])
        }
        result._checkInvariants()
        return result
      }
    }
  }
  @inlinable public mutating func formSymmetricDifference(_ other: __owned RecyclerView.OrderedSet<Element>) {
    self = self.symmetricDifference(other)
  }
  @inlinable @inline(__always) public __consuming func symmetricDifference(_ other: __owned RecyclerView.OrderedSet<Element>.UnorderedView) -> RecyclerView.OrderedSet<Element> {
    symmetricDifference(other._base)
  }
  @inlinable @inline(__always) public mutating func formSymmetricDifference(_ other: __owned RecyclerView.OrderedSet<Element>.UnorderedView) {
    formSymmetricDifference(other._base)
  }
  @inlinable public __consuming func symmetricDifference<S>(_ other: __owned S) -> RecyclerView.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
    _UnsafeBitset.withTemporaryBitset(capacity: self.count) { bitset in
      var new = Self()
      bitset.insertAll(upTo: self.count)
      for item in other {
        if let index = self._find(item).index {
          bitset.remove(index)
        } else {
          new.append(item)
        }
      }
      var result = _extractSubset(using: bitset, extraCapacity: new.count)
      for item in new._elements {
        result._appendNew(item)
      }
      result._checkInvariants()
      return result
    }
  }
  @inlinable public mutating func formSymmetricDifference<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
    self = self.symmetricDifference(other)
  }
}
extension RecyclerView.OrderedSet {
  @inlinable @inline(__always) public __consuming func subtracting(_ other: RecyclerView.OrderedSet<Element>) -> RecyclerView.OrderedSet<Element> {
    _subtracting(other)
  }
  @inlinable @inline(__always) public mutating func subtract(_ other: RecyclerView.OrderedSet<Element>) {
    self = subtracting(other)
  }
  @inlinable @inline(__always) public __consuming func subtracting(_ other: RecyclerView.OrderedSet<Element>.UnorderedView) -> RecyclerView.OrderedSet<Element> {
    subtracting(other._base)
  }
  @inlinable @inline(__always) public mutating func subtract(_ other: RecyclerView.OrderedSet<Element>.UnorderedView) {
    subtract(other._base)
  }
  @inlinable @inline(__always) public __consuming func subtracting<S>(_ other: S) -> RecyclerView.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
    _subtracting(other)
  }
  @inlinable @inline(__always) public mutating func subtract<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
    self = _subtracting(other)
  }
  @inlinable internal __consuming func _subtracting<S>(_ other: S) -> RecyclerView.OrderedSet<Element> where Element == S.Element, S : Swift.Sequence {
    guard count > 0 else { return Self() }
    return _UnsafeBitset.withTemporaryBitset(capacity: count) { difference in
      difference.insertAll(upTo: count)
      for item in other {
        if let index = self._find(item).index {
          if difference.remove(index), difference.count == 0 {
            return Self()
          }
        }
      }
      assert(difference.count > 0)
      let result = _extractSubset(using: difference)
      result._checkInvariants()
      return result
    }
  }
}
extension RecyclerView.OrderedDictionary : Swift.Sequence {
  public typealias Element = (key: Key, value: Value)
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal let _base: RecyclerView.OrderedDictionary<Key, Value>
    @usableFromInline
    internal var _position: Swift.Int
    @inlinable @inline(__always) internal init(_base: RecyclerView.OrderedDictionary<Key, Value>) {
      self._base = _base
      self._position = 0
    }
    @inlinable public mutating func next() -> RecyclerView.OrderedDictionary<Key, Value>.Element? {
      guard _position < _base._values.count else { return nil }
      let result = (_base._keys[_position], _base._values[_position])
      _position += 1
      return result
    }
    public typealias Element = RecyclerView.OrderedDictionary<Key, Value>.Element
  }
  @inlinable @inline(__always) public var underestimatedCount: Swift.Int {
    get {
    count
  }
  }
  @inlinable @inline(__always) public func makeIterator() -> RecyclerView.OrderedDictionary<Key, Value>.Iterator {
    Iterator(_base: self)
  }
}
extension RecyclerView._HashTable.Header : Swift.CustomStringConvertible {
  @usableFromInline
  internal var _description: Swift.String {
    get
  }
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
extension RecyclerView._HashTable.UnsafeHandle : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
extension RecyclerView._HashTable : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
extension RecyclerView._HashTable.Storage : Swift.CustomStringConvertible {
  @usableFromInline
  final internal var description: Swift.String {
    get
  }
}
public enum ModelState : Swift.Hashable, Swift.CaseIterable {
  case beforeUpdate
  case afterUpdate
  public static func == (a: RecyclerView.ModelState, b: RecyclerView.ModelState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [RecyclerView.ModelState]
  public static var allCases: [RecyclerView.ModelState] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension RecyclerView._HashTable {
  @usableFromInline
  internal struct BucketIterator {
    @usableFromInline
    internal typealias Bucket = RecyclerView._HashTable.Bucket
    @usableFromInline
    internal var _currentBucket: RecyclerView._HashTable.BucketIterator.Bucket
    @usableFromInline
    @_effects(releasenone) internal init(hashTable: RecyclerView._UnsafeHashTable, startingAt bucket: RecyclerView._HashTable.BucketIterator.Bucket)
  }
}
extension RecyclerView._HashTable.UnsafeHandle {
  @usableFromInline
  internal typealias BucketIterator = RecyclerView._HashTable.BucketIterator
  @_effects(releasenone) @inlinable @inline(__always) internal func idealBucket(forHashValue hashValue: Swift.Int) -> RecyclerView._HashTable.UnsafeHandle.Bucket {
    return Bucket(offset: hashValue & (bucketCount - 1))
  }
  @inlinable @inline(__always) internal func idealBucket<Element>(for element: Element) -> RecyclerView._HashTable.UnsafeHandle.Bucket where Element : Swift.Hashable {
    let hashValue = element._rawHashValue(seed: seed)
    return idealBucket(forHashValue: hashValue)
  }
  @inlinable @inline(__always) internal func bucketIterator<Element>(for element: Element) -> RecyclerView._HashTable.UnsafeHandle.BucketIterator where Element : Swift.Hashable {
    let bucket = idealBucket(for: element)
    return bucketIterator(startingAt: bucket)
  }
  @inlinable @inline(__always) internal func bucketIterator(startingAt bucket: RecyclerView._HashTable.UnsafeHandle.Bucket) -> RecyclerView._HashTable.UnsafeHandle.BucketIterator {
    BucketIterator(hashTable: self, startingAt: bucket)
  }
  @usableFromInline
  @_effects(releasenone) internal func startFind(_ startBucket: RecyclerView._HashTable.UnsafeHandle.Bucket) -> (iterator: RecyclerView._HashTable.UnsafeHandle.BucketIterator, currentValue: Swift.Int?)
  @usableFromInline
  @_effects(readonly) internal func _startIterator(bucket: RecyclerView._HashTable.UnsafeHandle.Bucket) -> (currentBits: Swift.UInt64, nextBits: Swift.UInt64, remainingBitCount: Swift.Int)
}
extension RecyclerView._HashTable.BucketIterator {
  @inlinable @inline(__always) internal var currentBucket: RecyclerView._HashTable.BucketIterator.Bucket {
    get { _currentBucket }
  }
  @usableFromInline
  internal var isOccupied: Swift.Bool {
    @_effects(readonly) @inline(__always) get
  }
  @usableFromInline
  internal var currentValue: Swift.Int? {
    @inline(__always) @_effects(readonly) get
    @_effects(releasenone) set
  }
  @usableFromInline
  @_effects(releasenone) internal mutating func advance()
  @usableFromInline
  @_effects(releasenone) internal mutating func findNext() -> Swift.Int?
  @inlinable @_effects(releasenone) internal mutating func advance(until expected: Swift.Int) {
    while isOccupied && currentValue != expected {
      advance()
    }
  }
  @inlinable @_effects(releasenone) internal mutating func advanceToNextUnoccupiedBucket() {
    while isOccupied {
      advance()
    }
  }
}
extension RecyclerView.OrderedSet {
  @inlinable @inline(__always) public init<S>(uncheckedUniqueElements elements: S) where Element == S.Element, S : Swift.Sequence {
    let elements = ContiguousArray<Element>(elements)
    let table = _HashTable.create(uncheckedUniqueElements: elements)
    self.init(
      _uniqueElements: elements,
      elements.count > _HashTable.maximumUnhashedCount ? table : nil)
    _checkInvariants()
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public init<S>(_ elements: S) where Element == S.Element, S : Swift.Sequence {
    if S.self == Self.self {
      self = elements as! Self
      return
    }
    // Fast paths for when we know elements are all unique
    if S.self == Set<Element>.self || S.self == SubSequence.self {
      self.init(uncheckedUniqueElements: elements)
      return
    }

    self.init()
    append(contentsOf: elements)
  }
  @inlinable public init(_ elements: RecyclerView.OrderedSet<Element>) {
    self = elements
  }
  @inlinable public init(_ elements: RecyclerView.OrderedSet<Element>.SubSequence) {
    self.init(uncheckedUniqueElements: elements._slice)
  }
  @inlinable public init(_ elements: Swift.Set<Element>) {
    self.init(uncheckedUniqueElements: elements)
  }
  @inlinable public init<Value>(_ elements: Swift.Dictionary<Element, Value>.Keys) {
    self._elements = ContiguousArray(elements)
    _regenerateHashTable()
    _checkInvariants()
  }
  @inlinable public init<C>(_ elements: C) where Element == C.Element, C : Swift.RandomAccessCollection {
    // This code is careful not to copy storage if `C` is an Array
    // or ContiguousArray and the elements are already unique.
    let (table, firstDupe) = _HashTable.create(
      untilFirstDuplicateIn: elements)
    if firstDupe == elements.endIndex {
      // Fast path: `elements` consists of unique values.
      self.init(_uniqueElements: ContiguousArray(elements), table)
      return
    }

    // Otherwise keep the elements we've processed and add the rest one by one.
    self.init(_uniqueElements: ContiguousArray(elements[..<firstDupe]), table)
    self.append(contentsOf: elements[firstDupe...])
  }
}
extension RecyclerView.OrderedDictionary {
  @available(*, unavailable, message: "Please use `elements[offset]`")
  @inlinable @inline(__always) public subscript(offset offset: Swift.Int) -> RecyclerView.OrderedDictionary<Key, Value>.Element {
    get {
    fatalError()
  }
  }
}
extension RecyclerView.OrderedDictionary {
  @available(*, unavailable, renamed: "updateValue(forKey:default:with:)")
  @inlinable public mutating func modifyValue<R>(forKey key: Key, default defaultValue: @autoclosure () -> Value, _ body: (inout Value) throws -> R) rethrows -> R {
    fatalError()
  }
  @available(*, unavailable, renamed: "updateValue(forKey:insertingDefault:at:with:)")
  @inlinable public mutating func modifyValue<R>(forKey key: Key, insertingDefault defaultValue: @autoclosure () -> Value, at index: Swift.Int, _ body: (inout Value) throws -> R) rethrows -> R {
    fatalError()
  }
}
extension RecyclerView.OrderedDictionary {
  @frozen public struct Values {
    @usableFromInline
    internal var _base: RecyclerView.OrderedDictionary<Key, Value>
    @inlinable @inline(__always) internal init(_base: RecyclerView.OrderedDictionary<Key, Value>) {
      self._base = _base
    }
  }
}
extension RecyclerView.OrderedDictionary.Values {
  @inlinable @inline(__always) public var elements: Swift.Array<Value> {
    get {
    Array(_base._values)
  }
  }
}
extension RecyclerView.OrderedDictionary.Values {
  @inlinable @inline(__always) public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<RecyclerView.OrderedDictionary<Key, Value>.Values.Element>) throws -> R) rethrows -> R {
    try _base._values.withUnsafeBufferPointer(body)
  }
  @inlinable @inline(__always) public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<RecyclerView.OrderedDictionary<Key, Value>.Values.Element>) throws -> R) rethrows -> R {
    try _base._values.withUnsafeMutableBufferPointer(body)
  }
}
extension RecyclerView.OrderedDictionary.Values : Swift.Sequence {
  public typealias Element = Value
  public typealias Iterator = Swift.IndexingIterator<RecyclerView.OrderedDictionary<Key, Value>.Values>
}
extension RecyclerView.OrderedDictionary.Values : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { 0 }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _base._values.count }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
    i + distance
  }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
    _base._values.index(i, offsetBy: distance, limitedBy: limit)
  }
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
    end - start
  }
  @inlinable @inline(__always) public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Value>) throws -> R) rethrows -> R? {
    try _base._values.withUnsafeBufferPointer(body)
  }
  public typealias SubSequence = Swift.Slice<RecyclerView.OrderedDictionary<Key, Value>.Values>
}
extension RecyclerView.OrderedDictionary.Values : Swift.MutableCollection {
  @inlinable @inline(__always) public subscript(position: Swift.Int) -> Value {
    get {
      _base._values[position]
    }
    @inline(__always) _modify {
      yield &_base._values[position]
    }
  }
  @inlinable @inline(__always) public mutating func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
    _base._values.swapAt(i, j)
  }
  @inlinable @inline(__always) public mutating func partition(by belongsInSecondPartition: (Value) throws -> Swift.Bool) rethrows -> Swift.Int {
    try _base._values.partition(by: belongsInSecondPartition)
  }
  @inlinable @inline(__always) public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<RecyclerView.OrderedDictionary<Key, Value>.Values.Element>) throws -> R) rethrows -> R? {
    try _base._values.withUnsafeMutableBufferPointer(body)
  }
}
extension RecyclerView.OrderedDictionary.Values : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (left: RecyclerView.OrderedDictionary<Key, Value>.Values, right: RecyclerView.OrderedDictionary<Key, Value>.Values) -> Swift.Bool {
    left.elementsEqual(right)
  }
}
extension RecyclerView.OrderedDictionary.Values : Swift.Hashable where Value : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(count) // Discriminator
    for item in self {
      hasher.combine(item)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension RecyclerView._HashTable {
  @usableFromInline
  @frozen internal struct Bucket {
    @usableFromInline
    internal var offset: Swift.Int
    @inlinable @inline(__always) internal init(offset: Swift.Int) {
      assert(offset >= 0)
      self.offset = offset
    }
  }
}
extension RecyclerView._HashTable.Bucket : Swift.Equatable {
  @_transparent public static func == (left: RecyclerView._HashTable.Bucket, right: RecyclerView._HashTable.Bucket) -> Swift.Bool {
    left.offset == right.offset
  }
}
public enum LogType : Swift.Equatable, Swift.CaseIterable {
  case layoutSubviews
  case defaultRecycler
  case delegateMethods
  case longPress
  case dropInteraction
  case dragInteraction
  case contextMenu
  case selectionTap
  case engine
  case continuousModel
  case reusedCells
  case `default`
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RecyclerView.LogType, b: RecyclerView.LogType) -> Swift.Bool
  public typealias AllCases = [RecyclerView.LogType]
  public static var allCases: [RecyclerView.LogType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public func log(_ type: RecyclerView.LogType, _ item: @autoclosure () -> Swift.String, separator: Swift.String = " ", terminator: Swift.String = "\n")
public func log(_ type: RecyclerView.LogType, _ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n")
@_Concurrency.MainActor(unsafe) final public class RecyclerScrollView<Engine> : UIKit.UIScrollView, UIKit.UIScrollViewDelegate where Engine : RecyclerView.RecyclerViewEngine {
  @_Concurrency.MainActor(unsafe) @objc override final public var delegate: (any UIKit.UIScrollViewDelegate)? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) final public var allowsSelection: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var allowsMultipleSelection: Swift.Bool
  @_Concurrency.MainActor(unsafe) weak final public var recyclerViewDelegate: (any RecyclerView.RecyclerViewDelegate<Engine.Identifier, Engine.Payload>)?
  @_Concurrency.MainActor(unsafe) weak final public var dataSource: (any RecyclerView.RecyclerViewDataSource<Engine.Identifier, Engine.Payload>)?
  @_Concurrency.MainActor(unsafe) final public let engine: Engine
  @_Concurrency.MainActor(unsafe) public init(frame: CoreFoundation.CGRect, engine: Engine)
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override final public var frame: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) final public func reloadData()
  @_Concurrency.MainActor(unsafe) final public func applyModifications(_ actions: [RecyclerView.ModificationActions<Engine.Identifier>])
  @_Concurrency.MainActor(unsafe) final public func dequeueReusableViewWithIdentifier<View>(_ identifier: Engine.Identifier) -> View? where View : UIKit.UIView
  @_Concurrency.MainActor(unsafe) final public func payloadForIdentifier(_ identifier: Engine.Identifier) -> Engine.Payload?
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEstimatedPropertiesUpdated(_ touches: Swift.Set<UIKit.UITouch>)
  @_Concurrency.MainActor(unsafe) @objc override final public func pressesBegan(_ presses: Swift.Set<UIKit.UIPress>, with event: UIKit.UIPressesEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func pressesChanged(_ presses: Swift.Set<UIKit.UIPress>, with event: UIKit.UIPressesEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func pressesEnded(_ presses: Swift.Set<UIKit.UIPress>, with event: UIKit.UIPressesEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func pressesCancelled(_ presses: Swift.Set<UIKit.UIPress>, with event: UIKit.UIPressesEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func motionBegan(_ motion: UIKit.UIEvent.EventSubtype, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func motionEnded(_ motion: UIKit.UIEvent.EventSubtype, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func motionCancelled(_ motion: UIKit.UIEvent.EventSubtype, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidZoom(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewWillEndDragging(_ scrollView: UIKit.UIScrollView, withVelocity velocity: CoreFoundation.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewWillBeginDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidEndScrollingAnimation(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func viewForZooming(in scrollView: UIKit.UIScrollView) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewWillBeginZooming(_ scrollView: UIKit.UIScrollView, with view: UIKit.UIView?)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidEndZooming(_ scrollView: UIKit.UIScrollView, with view: UIKit.UIView?, atScale scale: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewShouldScrollToTop(_ scrollView: UIKit.UIScrollView) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidScrollToTop(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc final public func scrollViewDidChangeAdjustedContentInset(_ scrollView: UIKit.UIScrollView)
  @objc deinit
}
extension RecyclerView.RecyclerScrollView where Engine : RecyclerView.PositionSnapshotSupportingEngine {
  @_Concurrency.MainActor(unsafe) final public func getPositionSnapshot(from edge: Engine.Edge) -> Engine.PositionSnapshot?
  @_Concurrency.MainActor(unsafe) final public func scrollToPositionSnapshot(_ positionSnapshot: Engine.PositionSnapshot, animated: Swift.Bool, completion: ((Swift.Bool) -> Swift.Void)? = nil)
}
public struct ScrollViewParameters : Swift.Equatable {
  public var contentSize: CoreFoundation.CGSize
  public var contentOffset: CoreFoundation.CGPoint
  public init(contentSize: CoreFoundation.CGSize, contentOffset: CoreFoundation.CGPoint)
  public init(scrollView: UIKit.UIScrollView)
  public static func == (a: RecyclerView.ScrollViewParameters, b: RecyclerView.ScrollViewParameters) -> Swift.Bool
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol RecyclerViewDataSource<Identifier, Payload> : AnyObject {
  associatedtype Identifier : Swift.Hashable
  associatedtype Payload : Swift.Equatable
  func allIdentifiers() -> [Self.Identifier]
  func viewForIdentifier(_ identifier: Self.Identifier) -> UIKit.UIView
  func payloadForIdentifier(_ identifier: Self.Identifier) -> Self.Payload
  func reconfigureView(_ view: UIKit.UIView, with identifier: Self.Identifier)
}
#else
public protocol RecyclerViewDataSource : AnyObject {
  associatedtype Identifier : Swift.Hashable
  associatedtype Payload : Swift.Equatable
  func allIdentifiers() -> [Self.Identifier]
  func viewForIdentifier(_ identifier: Self.Identifier) -> UIKit.UIView
  func payloadForIdentifier(_ identifier: Self.Identifier) -> Self.Payload
  func reconfigureView(_ view: UIKit.UIView, with identifier: Self.Identifier)
}
#endif
extension RecyclerView.OrderedDictionary : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_Concurrency.MainActor(unsafe) final public class InteractiveMoveInteraction<Engine> : ObjectiveC.NSObject, UIKit.UIInteraction where Engine : RecyclerView.InteractiveReorderingSupportingEngine {
  @_Concurrency.MainActor(unsafe) final public let longPressGestureRecogniser: RecyclerView.LongPressInteractiveMoveGestureRecogniser<Engine>
  @_Concurrency.MainActor(unsafe) @objc final public var view: UIKit.UIView? {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) public init(engine: Engine)
  @_Concurrency.MainActor(unsafe) @objc final public func willMove(to view: UIKit.UIView?)
  @_Concurrency.MainActor(unsafe) @objc final public func didMove(to view: UIKit.UIView?)
  @objc deinit
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol CellContext<Identifier> {
  associatedtype Identifier : Swift.Hashable
  var identifier: Self.Identifier { get }
  func performWithoutCellConstraints<C>(_ block: (UIKit.UIView) -> C) -> C
}
#else
public protocol CellContext {
  associatedtype Identifier : Swift.Hashable
  var identifier: Self.Identifier { get }
  func performWithoutCellConstraints<C>(_ block: (UIKit.UIView) -> C) -> C
}
#endif
extension RecyclerView.OrderedSet : Swift.ExpressibleByArrayLiteral {
  @inlinable public init(arrayLiteral elements: Element...) {
    self.init(elements)
  }
  public typealias ArrayLiteralElement = Element
}
extension RecyclerView.OrderedSet {
  @frozen public struct _UnstableInternals {
    @usableFromInline
    internal typealias _Bucket = RecyclerView._HashTable.Bucket
    @usableFromInline
    internal var base: RecyclerView.OrderedSet<Element>
    @inlinable internal init(_ base: RecyclerView.OrderedSet<Element>) {
      self.base = base
    }
  }
  @inlinable public var __unstable: RecyclerView.OrderedSet<Element>._UnstableInternals {
    @inline(__always) get {
      _UnstableInternals(self)
    }
    @inline(__always) _modify {
      var view = _UnstableInternals(self)
      self = OrderedSet()
      defer { self = view.base }
      yield &view
    }
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public mutating func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
    guard i != j else { return }
    _elements.swapAt(i, j)
    guard _table != nil else { return }
    _ensureUnique()
    _table!.update { hashTable in
      hashTable.swapBucketValues(for: _elements[i], withCurrentValue: j,
                                 and: _elements[j], withCurrentValue: i)
    }
    _checkInvariants()
  }
  @inlinable public mutating func partition(by belongsInSecondPartition: (Element) throws -> Swift.Bool) rethrows -> Swift.Int {
    try _partition(by: belongsInSecondPartition, callback: { a, b in })
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public mutating func _partition(by belongsInSecondPartition: (Element) throws -> Swift.Bool, callback: (Swift.Int, Swift.Int) -> Swift.Void) rethrows -> Swift.Int {
    guard _table != nil else {
      return try _elements.partition(by: belongsInSecondPartition)
    }
    _ensureUnique()
    let result: Int = try _table!.update { hashTable in
      let maybeOffset: Int? = try _elements.withContiguousMutableStorageIfAvailable { buffer in
        let pivot = try buffer._partition(
          with: hashTable,
          by: belongsInSecondPartition,
          callback: callback)
        return pivot - buffer.startIndex
      }
      if let offset = maybeOffset {
        return _elements.index(startIndex, offsetBy: offset)
      }
      return try _elements._partition(
        with: hashTable,
        by: belongsInSecondPartition,
        callback: callback)
    }
    _checkInvariants()
    return result
  }
}
extension Swift.MutableCollection where Self : Swift.RandomAccessCollection, Self.Element : Swift.Hashable {
  @inlinable internal mutating func _partition(with hashTable: RecyclerView._UnsafeHashTable, by belongsInSecondPartition: (Self.Element) throws -> Swift.Bool, callback: (Swift.Int, Swift.Int) -> Swift.Void) rethrows -> Self.Index {
    var low = startIndex
    var high = endIndex

    while true {
      // Invariants at this point:
      // - low <= high
      // - all elements in `startIndex ..< low` belong in the first partition
      // - all elements in `high ..< endIndex` belong in the second partition

      // Find next element from `lo` that may not be in the right place.
      while true {
        if low == high { return low }
        if try belongsInSecondPartition(self[low]) { break }
        formIndex(after: &low)
      }

      // Find next element down from `hi` that we can swap `lo` with.
      while true {
        formIndex(before: &high)
        if low == high { return low }
        if try !belongsInSecondPartition(self[high]) { break }
      }

      // Swap the two elements as well as their associated hash table buckets.
      swapAt(low, high)
      let offsetLow = _offset(of: low)
      let offsetHigh = _offset(of: high)
      hashTable.swapBucketValues(for: self[low], withCurrentValue: offsetHigh,
                                 and: self[high], withCurrentValue: offsetLow)
      callback(offsetLow, offsetHigh)

      formIndex(after: &low)
    }
  }
}
extension RecyclerView._HashTable.UnsafeHandle {
  @inlinable @inline(__always) internal func swapBucketValues<Element>(for left: Element, withCurrentValue leftValue: Swift.Int, and right: Element, withCurrentValue rightValue: Swift.Int) where Element : Swift.Hashable {
    let left = idealBucket(for: left)
    let right = idealBucket(for: right)
    swapBucketValues(for: left, withCurrentValue: leftValue,
                     and: right, withCurrentValue: rightValue)
  }
  @usableFromInline
  @_effects(releasenone) internal func swapBucketValues(for left: RecyclerView._HashTable.UnsafeHandle.Bucket, withCurrentValue leftValue: Swift.Int, and right: RecyclerView._HashTable.UnsafeHandle.Bucket, withCurrentValue rightValue: Swift.Int)
}
extension RecyclerView.OrderedSet {
  @inlinable public mutating func sort(by areInIncreasingOrder: (Element, Element) throws -> Swift.Bool) rethrows {
    defer {
      // Note: This assumes that `sort(by:)` won't leave duplicate/missing
      // elements in the table when the closure throws. This matches the
      // stdlib's behavior in Swift 5.3, and it seems like a reasonable
      // long-term assumption.
      _regenerateExistingHashTable()
      _checkInvariants()
    }
    try _elements.sort(by: areInIncreasingOrder)
  }
}
extension RecyclerView.OrderedSet where Element : Swift.Comparable {
  @inlinable public mutating func sort() {
    defer {
      // Note: This assumes that `sort(by:)` won't leave duplicate/missing
      // elements in the table when the closure throws. This matches the
      // stdlib's behavior in Swift 5.3, and it seems like a reasonable
      // long-term assumption.
      _regenerateExistingHashTable()
      _checkInvariants()
    }
    _elements.sort()
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public mutating func shuffle() {
    var generator = SystemRandomNumberGenerator()
    shuffle(using: &generator)
  }
  @inlinable public mutating func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator {
    _elements.shuffle(using: &generator)
    _regenerateExistingHashTable()
    _checkInvariants()
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public mutating func reverse() {
    _elements.reverse()
    // FIXME: Update hash table contents in place.
    _regenerateHashTable()
    _checkInvariants()
  }
}
extension RecyclerView.OrderedSet {
  @inlinable internal mutating func _halfStablePartition<Value>(values: Swift.UnsafeMutableBufferPointer<Value>, by belongsInSecondPartition: ((key: Element, value: Value)) throws -> Swift.Bool) rethrows -> Swift.Int {
    precondition(self.count == values.count)
    var i = 0
    try _elements.withUnsafeMutableBufferPointer { keys in
      while i < keys.count, try !belongsInSecondPartition((keys[i], values[i])) {
        i += 1
      }
    }
    guard i < self.count else { return self.count }

    self._ensureUnique()
    let table = _table
    self._table = nil
    defer { self._table = table }

    return try _elements.withUnsafeMutableBufferPointer { keys in
      for j in i + 1 ..< keys.count {
        guard try !belongsInSecondPartition((keys[j], values[j])) else {
          continue
        }
        keys.swapAt(i, j)
        values.swapAt(i, j)
        table?.update { hashTable in
          hashTable.swapBucketValues(for: keys[i], withCurrentValue: j,
                                     and: keys[j], withCurrentValue: i)
        }
        i += 1
      }
      return i
    }
  }
  @inlinable internal mutating func _partition<Value>(values: Swift.UnsafeMutableBufferPointer<Value>, by belongsInSecondPartition: ((key: Element, value: Value)) throws -> Swift.Bool) rethrows -> Swift.Int {
    self._ensureUnique()
    let table = self._table
    self._table = nil
    defer { self._table = table }
    return try _elements.withUnsafeMutableBufferPointer { keys in
      assert(keys.count == values.count)
      var low = keys.startIndex
      var high = keys.endIndex

      while true {
        // Invariants at this point:
        // - low <= high
        // - all elements in `startIndex ..< low` belong in the first partition
        // - all elements in `high ..< endIndex` belong in the second partition

        // Find next element from `lo` that may not be in the right place.
        while true {
          if low == high { return low }
          if try belongsInSecondPartition((keys[low], values[low])) { break }
          low += 1
        }

        // Find next element down from `hi` that we can swap `lo` with.
        while true {
          high -= 1
          if low == high { return low }
          if try !belongsInSecondPartition((keys[high], values[high])) { break }
        }

        // Swap the two elements as well as their associated hash table buckets.
        keys.swapAt(low, high)
        values.swapAt(low, high)
        table?.update { hashTable in
          hashTable.swapBucketValues(for: keys[low], withCurrentValue: high,
                                     and: keys[high], withCurrentValue: low)
        }
        low += 1
      }
    }
  }
}
extension RecyclerView._HashTable.Bucket : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RecyclerView._HashTable.BucketIterator : Swift.CustomStringConvertible {
  @usableFromInline
  internal var description: Swift.String {
    get
  }
}
extension Swift.RandomAccessCollection where Self.Index == Swift.Int {
  @inlinable @inline(__always) internal func binarySearch(predicate: (Self.Element) -> Foundation.ComparisonResult) -> Self.Index? {
        var lowerBound = startIndex
        var upperBound = endIndex

        while lowerBound < upperBound {
            let midIndex = lowerBound &+ (upperBound &- lowerBound) / 2
            let result = predicate(self[midIndex])
            if result == .orderedSame {
                return midIndex
            } else if result == .orderedAscending {
                lowerBound = midIndex &+ 1
            } else {
                upperBound = midIndex
            }
        }
        return nil
    }
  @inlinable @inline(__always) internal func binarySearchRange(predicate: (Self.Element) -> Foundation.ComparisonResult) -> [Self.Element] {
        @inline(__always)
        func leftMostSearch(lowerBound: Index, upperBound: Index) -> Index? {
            var lowerBound = lowerBound
            var upperBound = upperBound

            while lowerBound < upperBound {
                let midIndex = (lowerBound &+ upperBound) / 2
                if predicate(self[midIndex]) == .orderedAscending {
                    lowerBound = midIndex &+ 1
                } else {
                    upperBound = midIndex
                }
            }
            if predicate(self[lowerBound]) == .orderedSame {
                return lowerBound
            } else {
                return nil
            }
        }

        @inline(__always)
        func rightMostSearch(lowerBound: Index, upperBound: Index) -> Index? {
            var lowerBound = lowerBound
            var upperBound = upperBound

            while lowerBound < upperBound {
                let midIndex = (lowerBound &+ upperBound &+ 1) / 2
                if predicate(self[midIndex]) == .orderedDescending {
                    upperBound = midIndex &- 1
                } else {
                    lowerBound = midIndex
                }
            }
            if predicate(self[lowerBound]) == .orderedSame {
                return lowerBound
            } else {
                return nil
            }
        }

        guard !isEmpty,
              let lowerBound = leftMostSearch(lowerBound: startIndex, upperBound: endIndex - 1),
              let upperBound = rightMostSearch(lowerBound: startIndex, upperBound: endIndex - 1) else {
            return []
        }

        return Array(self[lowerBound...upperBound])
    }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol LayoutCoordinator<Identifier, Payload> {
  associatedtype Identifier : Swift.Hashable
  associatedtype Payload : Swift.Equatable
  var identifiers: [Self.Identifier] { get }
  var representation: any RecyclerView.ScrollViewRepresentation { get }
  var scrollView: UIKit.UIScrollView? { get }
  func payloadForIdentifier(_ identifier: Self.Identifier) -> Self.Payload
}
#else
public protocol LayoutCoordinator {
  associatedtype Identifier : Swift.Hashable
  associatedtype Payload : Swift.Equatable
  var identifiers: [Self.Identifier] { get }
  var representation: any RecyclerView.ScrollViewRepresentation { get }
  var scrollView: UIKit.UIScrollView? { get }
  func payloadForIdentifier(_ identifier: Self.Identifier) -> Self.Payload
}
#endif
extension RecyclerView.OrderedSet {
  @frozen public struct UnorderedView {
    @usableFromInline
    internal var _base: RecyclerView.OrderedSet<Element>
    @inlinable @inline(__always) internal init(_base: RecyclerView.OrderedSet<Element>) {
      self._base = _base
    }
  }
  @inlinable @inline(__always) public init(_ view: RecyclerView.OrderedSet<Element>.UnorderedView) {
    self = view._base
  }
  @inlinable public var unordered: RecyclerView.OrderedSet<Element>.UnorderedView {
    @inline(__always) get {
      UnorderedView(_base: self)
    }
    @inline(__always) _modify {
      var view = UnorderedView(_base: self)
      self = OrderedSet()
      defer { self = view._base }
      yield &view
    }
  }
}
extension RecyclerView.OrderedSet.UnorderedView : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RecyclerView.OrderedSet.UnorderedView : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RecyclerView.OrderedSet.UnorderedView : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension RecyclerView.OrderedSet.UnorderedView : Swift.Equatable {
  @inlinable public static func == (left: RecyclerView.OrderedSet<Element>.UnorderedView, right: RecyclerView.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
    if left._base.__storage != nil,
       left._base.__storage === right._base.__storage
    {
      return true
    }
    guard left._base.count == right._base.count else { return false }

    for item in left._base {
      if !right._base.contains(item) { return false }
    }
    return true
  }
}
extension RecyclerView.OrderedSet.UnorderedView : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    // Generate a seed from a snapshot of the hasher.  This makes members' hash
    // values depend on the state of the hasher, which improves hashing
    // quality. (E.g., it makes it possible to resolve collisions by passing in
    // a different hasher.)
    let copy = hasher
    let seed = copy.finalize()

    var hash = 0
    for member in _base {
      hash ^= member._rawHashValue(seed: seed)
    }
    hasher.combine(hash)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension RecyclerView.OrderedSet.UnorderedView : Swift.ExpressibleByArrayLiteral {
  @inlinable @inline(__always) public init(arrayLiteral elements: Element...) {
    _base = OrderedSet(elements)
  }
  public typealias ArrayLiteralElement = Element
}
extension RecyclerView.OrderedSet.UnorderedView : Swift.SetAlgebra {
  public typealias Element = RecyclerView.OrderedSet<Element>.Element
}
extension RecyclerView.OrderedSet.UnorderedView {
  @inlinable @inline(__always) public init() {
    _base = OrderedSet()
  }
  @inlinable @inline(__always) public init<S>(_ elements: S) where Element == S.Element, S : Swift.Sequence {
    _base = OrderedSet(elements)
  }
  @inlinable @inline(__always) public init(_ elements: RecyclerView.OrderedSet<Element>.UnorderedView) {
    self = elements
  }
  @inlinable @inline(__always) public init(_ elements: Swift.Set<Element>) {
    self._base = OrderedSet(elements)
  }
  @inlinable @inline(__always) public init<Value>(_ elements: Swift.Dictionary<Element, Value>.Keys) {
    self._base = OrderedSet(elements)
  }
}
extension RecyclerView.OrderedSet.UnorderedView {
  @inlinable @inline(__always) public func contains(_ element: Element) -> Swift.Bool {
    _base.contains(element)
  }
}
extension RecyclerView.OrderedSet.UnorderedView {
  @inlinable public mutating func insert(_ newMember: __owned Element) -> (inserted: Swift.Bool, memberAfterInsert: Element) {
    let (inserted, index) = _base.append(newMember)
    return (inserted, _base[index])
  }
  @inlinable public mutating func update(with newMember: __owned Element) -> Element? {
    let (inserted, index) = _base.append(newMember)
    if inserted { return nil }
    let old = _base._elements[index]
    _base._elements[index] = newMember
    return old
  }
}
extension RecyclerView.OrderedSet.UnorderedView {
  @discardableResult
  @inlinable @inline(__always) public mutating func remove(_ member: Element) -> Element? {
    _base.remove(member)
  }
}
extension RecyclerView.OrderedSet.UnorderedView {
  @inlinable @inline(__always) public mutating func formUnion(_ other: __owned RecyclerView.OrderedSet<Element>.UnorderedView) {
    _base.formUnion(other._base)
  }
  @inlinable public __consuming func union(_ other: __owned RecyclerView.OrderedSet<Element>.UnorderedView) -> RecyclerView.OrderedSet<Element>.UnorderedView {
    _base.union(other._base).unordered
  }
  @inlinable public mutating func formUnion<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
    _base.formUnion(other)
  }
  @inlinable public __consuming func union<S>(_ other: __owned S) -> RecyclerView.OrderedSet<Element>.UnorderedView where Element == S.Element, S : Swift.Sequence {
    _base.union(other).unordered
  }
}
extension RecyclerView.OrderedSet.UnorderedView {
  @inlinable public __consuming func intersection(_ other: RecyclerView.OrderedSet<Element>.UnorderedView) -> RecyclerView.OrderedSet<Element>.UnorderedView {
    _base.intersection(other._base).unordered
  }
  @inlinable public mutating func formIntersection(_ other: RecyclerView.OrderedSet<Element>.UnorderedView) {
    _base.formIntersection(other._base)
  }
  @inlinable public __consuming func intersection<S>(_ other: S) -> RecyclerView.OrderedSet<Element>.UnorderedView where Element == S.Element, S : Swift.Sequence {
    _base.intersection(other).unordered
  }
  @inlinable public mutating func formIntersection<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
    _base.formIntersection(other)
  }
}
extension RecyclerView.OrderedSet.UnorderedView {
  @inlinable public __consuming func symmetricDifference(_ other: __owned RecyclerView.OrderedSet<Element>.UnorderedView) -> RecyclerView.OrderedSet<Element>.UnorderedView {
    _base.symmetricDifference(other._base).unordered
  }
  @inlinable public mutating func formSymmetricDifference(_ other: __owned RecyclerView.OrderedSet<Element>.UnorderedView) {
    _base.formSymmetricDifference(other._base)
  }
  @inlinable public __consuming func symmetricDifference<S>(_ other: __owned S) -> RecyclerView.OrderedSet<Element>.UnorderedView where Element == S.Element, S : Swift.Sequence {
    _base.symmetricDifference(other).unordered
  }
  @inlinable public mutating func formSymmetricDifference<S>(_ other: __owned S) where Element == S.Element, S : Swift.Sequence {
    _base.formSymmetricDifference(other)
  }
}
extension RecyclerView.OrderedSet.UnorderedView {
  @inlinable public __consuming func subtracting(_ other: RecyclerView.OrderedSet<Element>.UnorderedView) -> RecyclerView.OrderedSet<Element>.UnorderedView {
    _base.subtracting(other._base).unordered
  }
  @inlinable public mutating func subtract(_ other: RecyclerView.OrderedSet<Element>.UnorderedView) {
    _base.subtract(other._base)
  }
  @inlinable public __consuming func subtracting<S>(_ other: S) -> RecyclerView.OrderedSet<Element>.UnorderedView where Element == S.Element, S : Swift.Sequence {
    _base.subtracting(other).unordered
  }
  @inlinable public mutating func subtract<S>(_ other: S) where Element == S.Element, S : Swift.Sequence {
    _base.subtract(other)
  }
}
extension RecyclerView.OrderedSet.UnorderedView {
  @inlinable public func isSubset(of other: RecyclerView.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
    _base.isSubset(of: other._base)
  }
  @inlinable public func isSubset(of other: Swift.Set<Element>) -> Swift.Bool {
    _base.isSubset(of: other)
  }
  @inlinable public func isSubset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    _base.isSubset(of: other)
  }
}
extension RecyclerView.OrderedSet.UnorderedView {
  @inlinable public func isSuperset(of other: RecyclerView.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
    _base.isSuperset(of: other._base)
  }
  @inlinable public func isSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
    _base.isSuperset(of: other)
  }
  @inlinable public func isSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    _base.isSuperset(of: other)
  }
}
extension RecyclerView.OrderedSet.UnorderedView {
  @inlinable public func isStrictSubset(of other: RecyclerView.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
    _base.isStrictSubset(of: other._base)
  }
  @inlinable public func isStrictSubset(of other: Swift.Set<Element>) -> Swift.Bool {
    _base.isStrictSubset(of: other)
  }
  @inlinable public func isStrictSubset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    _base.isStrictSubset(of: other)
  }
}
extension RecyclerView.OrderedSet.UnorderedView {
  @inlinable public func isStrictSuperset(of other: RecyclerView.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
    _base.isStrictSuperset(of: other._base)
  }
  @inlinable public func isStrictSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
    _base.isStrictSuperset(of: other)
  }
  @inlinable public func isStrictSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    _base.isStrictSuperset(of: other)
  }
}
extension RecyclerView.OrderedSet.UnorderedView {
  @inlinable public func isDisjoint(with other: RecyclerView.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
    _base.isDisjoint(with: other._base)
  }
  @inlinable public func isDisjoint(with other: Swift.Set<Element>) -> Swift.Bool {
    _base.isDisjoint(with: other)
  }
  @inlinable public func isDisjoint<S>(with other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    _base.isDisjoint(with: other)
  }
}
extension RecyclerView.OrderedSet {
  @frozen public struct SubSequence {
    @usableFromInline
    internal var _base: RecyclerView.OrderedSet<Element>
    @usableFromInline
    internal var _bounds: Swift.Range<Swift.Int>
    @inlinable @inline(__always) internal init(_base: RecyclerView.OrderedSet<Element>, bounds: Swift.Range<Swift.Int>) {
      self._base = _base
      self._bounds = bounds
    }
  }
}
extension RecyclerView.OrderedSet.SubSequence {
  @inlinable internal var _slice: Swift.Array<Element>.SubSequence {
    get {
    _base._elements[_bounds]
  }
  }
  @inlinable internal func _index(of element: Element) -> Swift.Int? {
    guard let index = _base._find(element).index else { return nil }
    guard _bounds.contains(index) else { return nil }
    return index
  }
}
extension RecyclerView.OrderedSet.SubSequence : Swift.Sequence {
  public typealias Element = RecyclerView.OrderedSet<Element>.Element
  public typealias Iterator = Swift.IndexingIterator<RecyclerView.OrderedSet<Element>.SubSequence>
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    _index(of: element) != nil
  }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    _slice._copyToContiguousArray()
  }
  @inlinable public __consuming func _copyContents(initializing ptr: Swift.UnsafeMutableBufferPointer<Element>) -> (RecyclerView.OrderedSet<Element>.SubSequence.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    guard !isEmpty else { return (makeIterator(), 0) }
    let copied: Int = _slice.withUnsafeBufferPointer { buffer in
      guard let p = ptr.baseAddress else {
        preconditionFailure("Attempt to copy contents into nil buffer pointer")
      }
      let c = Swift.min(buffer.count, ptr.count)
      if c > 0 {
        p.initialize(from: buffer.baseAddress!, count: c)
      }
      return c
    }
    return (Iterator(_elements: self, _position: _bounds.lowerBound + copied),
            copied)
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    try _slice.withContiguousStorageIfAvailable(body)
  }
}
extension RecyclerView.OrderedSet.SubSequence : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Array<Element>.SubSequence.Indices
  public typealias SubSequence = RecyclerView.OrderedSet<Element>.SubSequence
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { _bounds.lowerBound }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _bounds.upperBound }
  }
  @inlinable @inline(__always) public var indices: RecyclerView.OrderedSet<Element>.SubSequence.Indices {
    get { _slice.indices }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
    i + distance
  }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
    _slice.index(i, offsetBy: distance, limitedBy: limit)
  }
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
    end - start
  }
  @inlinable @inline(__always) public subscript(position: Swift.Int) -> Element {
    get {
    _slice[position]
  }
  }
  @inlinable @inline(__always) public subscript(bounds: Swift.Range<Swift.Int>) -> RecyclerView.OrderedSet<Element>.SubSequence.SubSequence {
    get {
    _failEarlyRangeCheck(bounds, bounds: startIndex ..< endIndex)
    return SubSequence(_base: _base, bounds: bounds)
  }
  }
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _bounds.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _bounds.count }
  }
  @inlinable @inline(__always) public func _customIndexOfEquatableElement(_ element: Element) -> Swift.Int?? {
    .some(_index(of: element))
  }
  @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ element: Element) -> Swift.Int?? {
    .some(_index(of: element))
  }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
    _slice._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.ClosedRange<Swift.Int>) {
    _slice._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
    _slice._failEarlyRangeCheck(range, bounds: bounds)
  }
}
extension RecyclerView.OrderedSet.SubSequence : Swift.Equatable {
  @inlinable public static func == (left: RecyclerView.OrderedSet<Element>.SubSequence, right: RecyclerView.OrderedSet<Element>.SubSequence) -> Swift.Bool {
    left.elementsEqual(right)
  }
}
extension RecyclerView.OrderedSet.SubSequence : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    hasher.combine(count)
    for item in self {
      hasher.combine(item)
    }
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension RecyclerView.OrderedDictionary.Elements {
  @frozen public struct SubSequence {
    @usableFromInline
    internal var _base: RecyclerView.OrderedDictionary<Key, Value>
    @usableFromInline
    internal var _bounds: Swift.Range<Swift.Int>
    @inlinable @inline(__always) internal init(_base: RecyclerView.OrderedDictionary<Key, Value>, bounds: Swift.Range<Swift.Int>) {
      self._base = _base
      self._bounds = bounds
    }
  }
}
extension RecyclerView.OrderedDictionary.Elements.SubSequence {
  @inlinable @inline(__always) public var keys: RecyclerView.OrderedSet<Key>.SubSequence {
    get {
    _base._keys[_bounds]
  }
  }
  @inlinable @inline(__always) public var values: RecyclerView.OrderedDictionary<Key, Value>.Values.SubSequence {
    get {
    _base.values[_bounds]
  }
  }
}
extension RecyclerView.OrderedDictionary.Elements.SubSequence {
  @inlinable public func index(forKey key: Key) -> Swift.Int? {
    guard let index = _base.index(forKey: key) else { return nil }
    guard _bounds.contains(index) else { return nil }
    return index
  }
}
extension RecyclerView.OrderedDictionary.Elements.SubSequence : Swift.Sequence {
  public typealias Element = RecyclerView.OrderedDictionary<Key, Value>.Element
  @frozen public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal var _base: RecyclerView.OrderedDictionary<Key, Value>
    @usableFromInline
    internal var _end: Swift.Int
    @usableFromInline
    internal var _index: Swift.Int
    @inlinable @inline(__always) internal init(_base: RecyclerView.OrderedDictionary<Key, Value>.Elements.SubSequence) {
      self._base = _base._base
      self._end = _base._bounds.upperBound
      self._index = _base._bounds.lowerBound
    }
    @inlinable public mutating func next() -> RecyclerView.OrderedDictionary<Key, Value>.Elements.SubSequence.Element? {
      guard _index < _end else { return nil }
      defer { _index += 1 }
      return (_base._keys[_index], _base._values[_index])
    }
    public typealias Element = RecyclerView.OrderedDictionary<Key, Value>.Elements.SubSequence.Element
  }
  @inlinable @inline(__always) public func makeIterator() -> RecyclerView.OrderedDictionary<Key, Value>.Elements.SubSequence.Iterator {
    Iterator(_base: self)
  }
}
extension RecyclerView.OrderedDictionary.Elements.SubSequence : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = RecyclerView.OrderedDictionary<Key, Value>.Elements.SubSequence
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { _bounds.lowerBound }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _bounds.upperBound }
  }
  @inlinable @inline(__always) public var indices: Swift.Range<Swift.Int> {
    get { _bounds }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
    i + distance
  }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
    _base._values.index(i, offsetBy: distance, limitedBy: limit)
  }
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
    end - start
  }
  @inlinable public subscript(position: Swift.Int) -> RecyclerView.OrderedDictionary<Key, Value>.Elements.SubSequence.Element {
    get {
    precondition(_bounds.contains(position), "Index out of range")
    return (_base._keys[position], _base._values[position])
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> RecyclerView.OrderedDictionary<Key, Value>.Elements.SubSequence.SubSequence {
    get {
    precondition(
      bounds.lowerBound >= _bounds.lowerBound
        && bounds.upperBound <= _bounds.upperBound,
      "Index out of range")
    return Self(_base: _base, bounds: bounds)
  }
  }
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _bounds.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _bounds.count }
  }
}
extension RecyclerView.OrderedDictionary {
  @inline(__always) @inlinable public func _checkInvariants() {}
}
@_Concurrency.MainActor(unsafe) final public class SelectionInteraction<Engine> : ObjectiveC.NSObject, UIKit.UIInteraction where Engine : RecyclerView.TapSelectionGestureSupportingEngine {
  @_Concurrency.MainActor(unsafe) final public let selectionGestureRecogniser: RecyclerView.TapSelectionGestureRecogniser<Engine>
  @_Concurrency.MainActor(unsafe) @objc final public var view: UIKit.UIView? {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) public init(engine: Engine)
  @_Concurrency.MainActor(unsafe) @objc final public func willMove(to view: UIKit.UIView?)
  @_Concurrency.MainActor(unsafe) @objc final public func didMove(to view: UIKit.UIView?)
  @objc deinit
}
extension RecyclerView.OrderedSet {
  @inlinable public func isSubset(of other: RecyclerView.OrderedSet<Element>) -> Swift.Bool {
    guard other.count >= self.count else { return false }
    for item in self {
      guard other.contains(item) else { return false }
    }
    return true
  }
  @inlinable @inline(__always) public func isSubset(of other: RecyclerView.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
    isSubset(of: other._base)
  }
  @inlinable public func isSubset(of other: Swift.Set<Element>) -> Swift.Bool {
    guard other.count >= self.count else { return false }
    for item in self {
      guard other.contains(item) else { return false }
    }
    return true
  }
  @inlinable public func isSubset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    guard !isEmpty else { return true }
    return _UnsafeBitset.withTemporaryBitset(capacity: count) { seen in
      // Mark elements in `self` that we've seen in `other`.
      for item in other {
        if let index = _find(item).index {
          if seen.insert(index), seen.count == self.count {
            // We've seen enough.
            return true
          }
        }
      }
      return false
    }
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public func isSuperset(of other: RecyclerView.OrderedSet<Element>) -> Swift.Bool {
    other.isSubset(of: self)
  }
  @inlinable public func isSuperset(of other: RecyclerView.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
    isSuperset(of: other._base)
  }
  @inlinable public func isSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
    guard self.count >= other.count else { return false }
    return _isSuperset(of: other)
  }
  @inlinable public func isSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    _isSuperset(of: other)
  }
  @inlinable internal func _isSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    for item in other {
      guard self.contains(item) else { return false }
    }
    return true
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public func isStrictSubset(of other: RecyclerView.OrderedSet<Element>) -> Swift.Bool {
    self.count < other.count && self.isSubset(of: other)
  }
  @inlinable @inline(__always) public func isStrictSubset(of other: RecyclerView.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
    isStrictSubset(of: other._base)
  }
  @inlinable public func isStrictSubset(of other: Swift.Set<Element>) -> Swift.Bool {
    self.count < other.count && self.isSubset(of: other)
  }
  @inlinable public func isStrictSubset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    _UnsafeBitset.withTemporaryBitset(capacity: count) { seen in
      // Mark elements in `self` that we've seen in `other`.
      var isKnownStrict = false
      for item in other {
        if let index = _find(item).index {
          if seen.insert(index), seen.count == self.count, isKnownStrict {
            // We've seen enough.
            return true
          }
        } else {
          if !isKnownStrict, seen.count == self.count { return true }
          isKnownStrict = true
        }
      }
      return false
    }
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public func isStrictSuperset(of other: RecyclerView.OrderedSet<Element>) -> Swift.Bool {
    self.count > other.count && other.isSubset(of: self)
  }
  @inlinable @inline(__always) public func isStrictSuperset(of other: RecyclerView.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
    isStrictSuperset(of: other._base)
  }
  @inlinable public func isStrictSuperset(of other: Swift.Set<Element>) -> Swift.Bool {
    self.count > other.count && other.isSubset(of: self)
  }
  @inlinable public func isStrictSuperset<S>(of other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    _UnsafeBitset.withTemporaryBitset(capacity: count) { seen in
      // Mark elements in `self` that we've seen in `other`.
      for item in other {
        guard let index = _find(item).index else {
          return false
        }
        if seen.insert(index), seen.count == self.count {
          // We've seen enough.
          return false
        }
      }
      return seen.count < self.count
    }
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public func isDisjoint(with other: RecyclerView.OrderedSet<Element>) -> Swift.Bool {
    guard !self.isEmpty && !other.isEmpty else { return true }
    if self.count <= other.count {
      for item in self {
        if other.contains(item) { return false }
      }
    } else {
      for item in other {
        if self.contains(item) { return false }
      }
    }
    return true
  }
  @inlinable @inline(__always) public func isDisjoint(with other: RecyclerView.OrderedSet<Element>.UnorderedView) -> Swift.Bool {
    isDisjoint(with: other._base)
  }
  @inlinable public func isDisjoint(with other: Swift.Set<Element>) -> Swift.Bool {
    guard !self.isEmpty && !other.isEmpty else { return true }
    if self.count <= other.count {
      for item in self {
        if other.contains(item) { return false }
      }
    } else {
      for item in other {
        if self.contains(item) { return false }
      }
    }
    return true
  }
  @inlinable public func isDisjoint<S>(with other: S) -> Swift.Bool where Element == S.Element, S : Swift.Sequence {
    guard !self.isEmpty else { return true }
    for item in other {
      if self.contains(item) { return false }
    }
    return true
  }
}
final public class SetActor<Option, ReactionType> where Option : Swift.SetAlgebra {
  public enum Action {
    case onEmpty
    case onChange
    case onInsertion(_: Option)
    case onRemoval(_: Option)
  }
  public enum ExecutionType {
    case once
    case eternal
    public static func == (a: RecyclerView.SetActor<Option, ReactionType>.ExecutionType, b: RecyclerView.SetActor<Option, ReactionType>.ExecutionType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public class Reaction {
    final public let type: ReactionType
    final public let action: RecyclerView.SetActor<Option, ReactionType>.Action
    final public let executionType: RecyclerView.SetActor<Option, ReactionType>.ExecutionType
    final public let actionBlock: () -> Swift.Void
    public init(type: ReactionType, action: RecyclerView.SetActor<Option, ReactionType>.Action, executionType: RecyclerView.SetActor<Option, ReactionType>.ExecutionType = .once, actionBlock: @escaping () -> Swift.Void)
    @objc deinit
  }
  final public var options: Option {
    get
    set
  }
  final public var reactions: [RecyclerView.SetActor<Option, ReactionType>.Reaction] {
    get
  }
  public init(options: Option = [], reactions: [RecyclerView.SetActor<Option, ReactionType>.Reaction] = [])
  final public func add(reaction: RecyclerView.SetActor<Option, ReactionType>.Reaction)
  final public func remove(reaction: RecyclerView.SetActor<Option, ReactionType>.Reaction)
  final public func removeAllReactions(where shouldBeRemoved: (RecyclerView.SetActor<Option, ReactionType>.Reaction) throws -> Swift.Bool) throws
  final public func removeAllReactions()
  @objc deinit
}
extension RecyclerView.SetActor where ReactionType : Swift.Equatable {
  final public func removeAllReactions(_ type: ReactionType)
}
extension RecyclerView.OrderedDictionary {
  @inlinable @inline(__always) public init() {
    self._keys = OrderedSet()
    self._values = []
  }
  @inlinable @inline(__always) public init(minimumCapacity: Swift.Int, persistent: Swift.Bool = false) {
    self._keys = OrderedSet(minimumCapacity: minimumCapacity, persistent: persistent)
    self._values = []
    _values.reserveCapacity(minimumCapacity)
  }
}
extension RecyclerView.OrderedDictionary {
  @_disfavoredOverload @inlinable public init<S>(uniqueKeysWithValues keysAndValues: S) where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
    if S.self == Dictionary<Key, Value>.self {
      self.init(_uncheckedUniqueKeysWithValues: keysAndValues)
      return
    }
    self.init()
    reserveCapacity(keysAndValues.underestimatedCount)
    for (key, value) in keysAndValues {
      guard _keys._append(key).inserted else {
        preconditionFailure("Duplicate key: '\(key)'")
      }
      _values.append(value)
    }
  }
  @inlinable public init<S>(uniqueKeysWithValues keysAndValues: S) where S : Swift.Sequence, S.Element == (Key, Value) {
    self.init()
    reserveCapacity(keysAndValues.underestimatedCount)
    for (key, value) in keysAndValues {
      guard _keys._append(key).inserted else {
        preconditionFailure("Duplicate key: '\(key)'")
      }
      _values.append(value)
    }
  }
}
extension RecyclerView.OrderedDictionary {
  @inlinable public init<Keys, Values>(uniqueKeys keys: Keys, values: Values) where Key == Keys.Element, Value == Values.Element, Keys : Swift.Sequence, Values : Swift.Sequence {
    let keys = ContiguousArray(keys)
    let values = ContiguousArray(values)
    precondition(keys.count == values.count,
                 "Mismatching element counts between keys and values")
    self._keys = .init(keys)
    self._values = values
    precondition(_keys.count == _values.count, "Duplicate keys")
    _checkInvariants()
  }
}
extension RecyclerView.OrderedDictionary {
  @_disfavoredOverload @inlinable @inline(__always) public init<S>(_ keysAndValues: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
    self.init()
    try self.merge(keysAndValues, uniquingKeysWith: combine)
  }
  @inlinable @inline(__always) public init<S>(_ keysAndValues: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (Key, Value) {
    self.init()
    try self.merge(keysAndValues, uniquingKeysWith: combine)
  }
}
extension RecyclerView.OrderedDictionary {
  @inlinable public init<S>(grouping values: S, by keyForValue: (S.Element) throws -> Key) rethrows where Value : Swift.RangeReplaceableCollection, S : Swift.Sequence, Value.Element == S.Element {
    try self.init(_grouping: values, by: keyForValue)
  }
  @inlinable public init<S>(grouping values: S, by keyForValue: (S.Element) throws -> Key) rethrows where Value == [S.Element], S : Swift.Sequence {
    // Note: this extra overload is necessary to make type inference work
    // for the `Value` type -- we want it to default to `[S.Element`].
    // (https://github.com/apple/swift-collections/issues/139)
    try self.init(_grouping: values, by: keyForValue)
  }
  @inlinable internal init<S>(_grouping values: S, by keyForValue: (S.Element) throws -> Key) rethrows where Value : Swift.RangeReplaceableCollection, S : Swift.Sequence, Value.Element == S.Element {
    self.init()
    for value in values {
      let key = try keyForValue(value)
      self.updateValue(forKey: key, default: Value()) { array in
        array.append(value)
      }
    }
  }
}
extension RecyclerView.OrderedDictionary {
  @inlinable internal init<S>(_uncheckedUniqueKeysWithValues keysAndValues: S) where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
    self.init()
    reserveCapacity(keysAndValues.underestimatedCount)
    for (key, value) in keysAndValues {
      _keys._appendNew(key)
      _values.append(value)
    }
    _checkInvariants()
  }
  @_disfavoredOverload @inlinable public init<S>(uncheckedUniqueKeysWithValues keysAndValues: S) where S : Swift.Sequence, S.Element == (key: Key, value: Value) {
    self.init(_uncheckedUniqueKeysWithValues: keysAndValues)
  }
  @inlinable public init<S>(uncheckedUniqueKeysWithValues keysAndValues: S) where S : Swift.Sequence, S.Element == (Key, Value) {
    // Add tuple labels
    let keysAndValues = keysAndValues.lazy.map { (key: $0.0, value: $0.1) }
    self.init(uncheckedUniqueKeysWithValues: keysAndValues)
  }
}
extension RecyclerView.OrderedDictionary {
  @inlinable @inline(__always) public init<Keys, Values>(uncheckedUniqueKeys keys: Keys, values: Values) where Key == Keys.Element, Value == Values.Element, Keys : Swift.Sequence, Values : Swift.Sequence {
    self._keys = .init(uncheckedUniqueElements: keys)
    self._values = .init(values)
    precondition(_keys.count == _values.count)
    _checkInvariants()
  }
}
extension RecyclerView.OrderedDictionary {
  @frozen public struct Elements {
    @usableFromInline
    internal var _base: RecyclerView.OrderedDictionary<Key, Value>
    @inlinable @inline(__always) internal init(_base: RecyclerView.OrderedDictionary<Key, Value>) {
      self._base = _base
    }
  }
}
extension RecyclerView.OrderedDictionary {
  @inlinable @inline(__always) public var elements: RecyclerView.OrderedDictionary<Key, Value>.Elements {
    get {
      Elements(_base: self)
    }
    @inline(__always) _modify {
      var elements = Elements(_base: self)
      self = Self()
      defer { self = elements._base }
      yield &elements
    }
  }
}
extension RecyclerView.OrderedDictionary.Elements {
  @inlinable @inline(__always) public var keys: RecyclerView.OrderedSet<Key> {
    get {
    _base._keys
  }
  }
  @inlinable @inline(__always) public var values: RecyclerView.OrderedDictionary<Key, Value>.Values {
    get {
      _base.values
    }
    @inline(__always) _modify {
      var values = OrderedDictionary.Values(_base: _base)
      self = Self(_base: .init())
      defer { self._base = values._base }
      yield &values
    }
  }
}
extension RecyclerView.OrderedDictionary.Elements {
  @inlinable public func index(forKey key: Key) -> Swift.Int? {
    _base.index(forKey: key)
  }
}
extension RecyclerView.OrderedDictionary.Elements : Swift.Sequence {
  public typealias Element = (key: Key, value: Value)
  @inlinable public var underestimatedCount: Swift.Int {
    get { _base.count }
  }
  @inlinable public func makeIterator() -> RecyclerView.OrderedDictionary<Key, Value>.Iterator {
    _base.makeIterator()
  }
  public typealias Iterator = RecyclerView.OrderedDictionary<Key, Value>.Iterator
}
extension RecyclerView.OrderedDictionary.Elements : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { 0 }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _base.count }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
    i + distance
  }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
    _base._values.index(i, offsetBy: distance, limitedBy: limit)
  }
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
    end - start
  }
  @inlinable @inline(__always) public subscript(position: Swift.Int) -> RecyclerView.OrderedDictionary<Key, Value>.Elements.Element {
    get {
    (_base._keys[position], _base._values[position])
  }
  }
  public subscript(bounds: Swift.Range<Swift.Int>) -> RecyclerView.OrderedDictionary<Key, Value>.Elements.SubSequence {
    get
  }
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _base.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _base.count }
  }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
    _base._values._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.ClosedRange<Swift.Int>) {
    _base._values._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
    _base._values._failEarlyRangeCheck(range, bounds: bounds)
  }
}
extension RecyclerView.OrderedDictionary.Elements : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RecyclerView.OrderedDictionary.Elements : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RecyclerView.OrderedDictionary.Elements : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension RecyclerView.OrderedDictionary.Elements : Swift.Equatable where Value : Swift.Equatable {
  @inlinable public static func == (left: RecyclerView.OrderedDictionary<Key, Value>.Elements, right: RecyclerView.OrderedDictionary<Key, Value>.Elements) -> Swift.Bool {
    left._base == right._base
  }
}
extension RecyclerView.OrderedDictionary.Elements : Swift.Hashable where Value : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
    _base.hash(into: &hasher)
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension RecyclerView.OrderedDictionary.Elements {
  @inlinable @inline(__always) public mutating func swapAt(_ i: Swift.Int, _ j: Swift.Int) {
    _base.swapAt(i, j)
  }
  @inlinable @inline(__always) public mutating func partition(by belongsInSecondPartition: (RecyclerView.OrderedDictionary<Key, Value>.Elements.Element) throws -> Swift.Bool) rethrows -> Swift.Int {
    try _base.partition(by: belongsInSecondPartition)
  }
}
extension RecyclerView.OrderedDictionary.Elements {
  @inlinable @inline(__always) public mutating func sort(by areInIncreasingOrder: (RecyclerView.OrderedDictionary<Key, Value>.Elements.Element, RecyclerView.OrderedDictionary<Key, Value>.Elements.Element) throws -> Swift.Bool) rethrows {
    try _base.sort(by: areInIncreasingOrder)
  }
}
extension RecyclerView.OrderedDictionary.Elements where Key : Swift.Comparable {
  @inlinable @inline(__always) public mutating func sort() {
    _base.sort()
  }
}
extension RecyclerView.OrderedDictionary.Elements {
  @inlinable public mutating func shuffle() {
    _base.shuffle()
  }
  @inlinable public mutating func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator {
    _base.shuffle(using: &generator)
  }
}
extension RecyclerView.OrderedDictionary.Elements {
  @inlinable public mutating func reverse() {
    _base.reverse()
  }
}
extension RecyclerView.OrderedDictionary.Elements {
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    _base.removeAll(keepingCapacity: keepCapacity)
  }
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Int) -> RecyclerView.OrderedDictionary<Key, Value>.Elements.Element {
    _base.remove(at: index)
  }
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Int>) {
    _base.removeSubrange(bounds)
  }
  @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : Swift.RangeExpression, R.Bound == Swift.Int {
    _base.removeSubrange(bounds)
  }
  @discardableResult
  @inlinable public mutating func removeLast() -> RecyclerView.OrderedDictionary<Key, Value>.Elements.Element {
    _base.removeLast()
  }
  @inlinable public mutating func removeLast(_ n: Swift.Int) {
    _base.removeLast(n)
  }
  @discardableResult
  @inlinable public mutating func removeFirst() -> RecyclerView.OrderedDictionary<Key, Value>.Elements.Element {
    _base.removeFirst()
  }
  @inlinable public mutating func removeFirst(_ n: Swift.Int) {
    _base.removeFirst(n)
  }
  @inlinable public mutating func removeAll(where shouldBeRemoved: (RecyclerView.OrderedDictionary<Key, Value>.Elements.Element) throws -> Swift.Bool) rethrows {
    try _base.removeAll(where: shouldBeRemoved)
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol InvalidationCoordinator<Identifier> {
  associatedtype Identifier : Swift.Hashable
  var originalRepresentation: any RecyclerView.ScrollViewRepresentation { get }
  var processedIdentifiers: Swift.Set<Self.Identifier> { get }
  var existingIdentifiers: Swift.Set<Self.Identifier> { get }
  func updateScrollViewParameters(_ parameters: RecyclerView.ScrollViewParameters)
  func invalidateIdentifiers(_ identifiers: Swift.Set<Self.Identifier>)
  func invalidateLayout()
}
#else
public protocol InvalidationCoordinator {
  associatedtype Identifier : Swift.Hashable
  var originalRepresentation: any RecyclerView.ScrollViewRepresentation { get }
  var processedIdentifiers: Swift.Set<Self.Identifier> { get }
  var existingIdentifiers: Swift.Set<Self.Identifier> { get }
  func updateScrollViewParameters(_ parameters: RecyclerView.ScrollViewParameters)
  func invalidateIdentifiers(_ identifiers: Swift.Set<Self.Identifier>)
  func invalidateLayout()
}
#endif
extension RecyclerView._HashTable {
  @usableFromInline
  @inline(__always) internal static var minimumScale: Swift.Int {
    @_effects(readnone) get
  }
  @usableFromInline
  @inline(__always) internal static var maximumScale: Swift.Int {
    @_effects(readnone) get
  }
  @usableFromInline
  @inline(__always) internal static var maximumUnhashedCount: Swift.Int {
    @_effects(readnone) get
  }
  @usableFromInline
  @_effects(readnone) internal static func minimumCapacity(forScale scale: Swift.Int) -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func maximumCapacity(forScale scale: Swift.Int) -> Swift.Int
  @usableFromInline
  @_effects(readnone) internal static func scale(forCapacity capacity: Swift.Int) -> Swift.Int
}
public protocol TapSelectionStateSupporting {
  var selectionState: RecyclerView.TapSelectionState { get set }
}
public struct TapSelectionState : Swift.Hashable {
  public var isHighlighted: Swift.Bool
  public var isSelected: Swift.Bool
  public init(isHighlighted: Swift.Bool, isSelected: Swift.Bool)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RecyclerView.TapSelectionState, b: RecyclerView.TapSelectionState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol TapSelectionGestureSupportingEngine : RecyclerView.RecyclerViewEngine {
  func applyStateToCellWithIdentifier(_ identifier: Self.Identifier, state: RecyclerView.TapSelectionState)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class TapSelectionGestureRecogniser<Engine> : UIKit.UILongPressGestureRecognizer where Engine : RecyclerView.TapSelectionGestureSupportingEngine {
  @_Concurrency.MainActor(unsafe) @objc override final public func ignore(_ touch: UIKit.UITouch, for event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func canPrevent(_ preventedGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func canBePrevented(by preventingGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func shouldRequireFailure(of otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func shouldBeRequiredToFail(by otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func shouldReceive(_ event: UIKit.UIEvent) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func reset()
  @objc deinit
}
public struct ModificationActionsStorage<Identifier> where Identifier : Swift.Hashable {
  public struct ReloadedIdentifiers : Swift.Hashable {
    @usableFromInline
    internal let original: Identifier
    @usableFromInline
    internal let final: Identifier
    @usableFromInline
    internal init(original: Identifier, final: Identifier)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: RecyclerView.ModificationActionsStorage<Identifier>.ReloadedIdentifiers, b: RecyclerView.ModificationActionsStorage<Identifier>.ReloadedIdentifiers) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public let actions: [RecyclerView.ModificationActions<Identifier>]
  public let insertedIdentifiers: Swift.Set<Identifier>
  public let deletedIdentifiers: Swift.Set<Identifier>
  public let reloadedIdentifiers: Swift.Set<RecyclerView.ModificationActionsStorage<Identifier>.ReloadedIdentifiers>
  public let reconfiguredIdentifiers: Swift.Set<Identifier>
  public let movedIdentifiers: Swift.Set<Identifier>
  public let allModifierIdentifiers: Swift.Set<Identifier>
  public init(actions: [RecyclerView.ModificationActions<Identifier>])
  @inlinable @inline(__always) public static var empty: RecyclerView.ModificationActionsStorage<Identifier> {
    get {
        return ModificationActionsStorage(actions: [])
    }
  }
}
extension RecyclerView.OrderedDictionary : Swift.Encodable where Key : Swift.Encodable, Value : Swift.Encodable {
  @inlinable public func encode(to encoder: any Swift.Encoder) throws {
    // Encode contents as an array of alternating key-value pairs.
    var container = encoder.unkeyedContainer()
    for (key, value) in self {
      try container.encode(key)
      try container.encode(value)
    }
  }
}
extension RecyclerView.OrderedDictionary : Swift.Decodable where Key : Swift.Decodable, Value : Swift.Decodable {
  @inlinable public init(from decoder: any Swift.Decoder) throws {
    // We expect to be encoded as an array of alternating key-value pairs.
    var container = try decoder.unkeyedContainer()

    self.init()
    while !container.isAtEnd {
      let key = try container.decode(Key.self)
      let (index, bucket) = self._keys._find(key)
      guard index == nil else {
        let context = DecodingError.Context(
          codingPath: container.codingPath,
          debugDescription: "Duplicate key at offset \(container.currentIndex - 1)")
        throw DecodingError.dataCorrupted(context)
      }

      guard !container.isAtEnd else {
        throw DecodingError.dataCorrupted(
          DecodingError.Context(
            codingPath: container.codingPath,
            debugDescription: "Unkeyed container reached end before value in key-value pair"
          )
        )
      }
      let value = try container.decode(Value.self)
      _keys._appendNew(key, in: bucket)
      _values.append(value)
    }
    _checkInvariants()
  }
}
final public class UpdateStorage<T> {
  final public var beforeUpdate: T
  final public var afterUpdate: T {
    get
    set
  }
  final public var isAfterUpdateSetup: Swift.Bool {
    get
  }
  public init(beforeUpdate: T, afterUpdate: T? = nil, copyUsing copyBlock: @escaping (T) -> T = { return $0 })
  final public func dropAfterUpdate()
  @inlinable @inline(__always) final public func storageAt(_ state: RecyclerView.ModelState) -> T {
        switch state {
        case .beforeUpdate:
            return beforeUpdate
        case .afterUpdate:
            return afterUpdate
        }
    }
  @inlinable @inline(__always) final public func updateStorageAt(_ state: RecyclerView.ModelState, _ mutator: (inout T) -> Swift.Void) {
        switch state {
        case .beforeUpdate:
            mutator(&beforeUpdate)
        case .afterUpdate:
            mutator(&afterUpdate)
        }

    }
  @objc deinit
}
public enum ModificationActions<Identifier> : Swift.Hashable where Identifier : Swift.Hashable {
  public enum CaseType {
    case insert
    case reload
    case reconfigure
    case delete
    case move
    public static func == (a: RecyclerView.ModificationActions<Identifier>.CaseType, b: RecyclerView.ModificationActions<Identifier>.CaseType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @inlinable @inline(__always) public var caseType: RecyclerView.ModificationActions<Identifier>.CaseType {
    get {
        switch self {
        case .insert:
            return .insert
        case .reload:
            return .reload
        case .reconfigure:
            return .reconfigure
        case .delete:
            return .delete
        case .move:
            return .move
        }
    }
  }
  @inlinable @inline(__always) public var identifier: Identifier {
    get {
        switch self {
        case let .insert(identifier, at: _):
            return identifier
        case let .reload(identifier, with: _):
            return identifier
        case let .reconfigure(identifier):
            return identifier
        case let .delete(identifier):
            return identifier
        case let .move(identifier, to: _):
            return identifier
        }
    }
  }
  @inlinable @inline(__always) public var orderIndex: Swift.Int {
    get {
        switch self {
        case .delete:
            return 0
        case .reconfigure:
            return 1
        case .reload:
            return 2
        case .move:
            return 3
        case .insert:
            return 4
        }
    }
  }
  case insert(Identifier, at: Swift.Int)
  case reload(Identifier, with: Identifier)
  case reconfigure(Identifier)
  case delete(Identifier)
  case move(Identifier, to: Swift.Int)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RecyclerView.ModificationActions<Identifier>, b: RecyclerView.ModificationActions<Identifier>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CellConfiguration<Payload> : Swift.Equatable where Payload : Swift.Equatable {
  public var frame: CoreFoundation.CGRect
  public var alpha: CoreFoundation.CGFloat
  public var zIndex: Swift.Int
  public var transform: CoreFoundation.CGAffineTransform
  public var isHidden: Swift.Bool
  public var payload: Payload
  public init(frame: CoreFoundation.CGRect, alpha: CoreFoundation.CGFloat = 1, zIndex: Swift.Int = 0, transform: CoreFoundation.CGAffineTransform = .identity, isHidden: Swift.Bool = false, payload: Payload)
  public static func == (a: RecyclerView.CellConfiguration<Payload>, b: RecyclerView.CellConfiguration<Payload>) -> Swift.Bool
}
extension RecyclerView.OrderedSet {
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func difference(from other: RecyclerView.OrderedSet<Element>) -> Swift.CollectionDifference<Element>
  @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
  public func applying(_ difference: Swift.CollectionDifference<Element>) -> RecyclerView.OrderedSet<Element>?
}
extension RecyclerView.OrderedDictionary {
  @inlinable public mutating func reserveCapacity(_ minimumCapacity: Swift.Int) {
    self._keys.reserveCapacity(minimumCapacity)
    self._values.reserveCapacity(minimumCapacity)
  }
  @inlinable public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false) {
    _keys.removeAll(keepingCapacity: keepCapacity)
    _values.removeAll(keepingCapacity: keepCapacity)
  }
  @discardableResult
  @inlinable public mutating func remove(at index: Swift.Int) -> RecyclerView.OrderedDictionary<Key, Value>.Element {
    let key = _keys.remove(at: index)
    let value = _values.remove(at: index)
    return (key, value)
  }
  @inlinable public mutating func removeSubrange(_ bounds: Swift.Range<Swift.Int>) {
    _keys.removeSubrange(bounds)
    _values.removeSubrange(bounds)
  }
  @inlinable public mutating func removeSubrange<R>(_ bounds: R) where R : Swift.RangeExpression, R.Bound == Swift.Int {
    removeSubrange(bounds.relative(to: elements))
  }
  @discardableResult
  @inlinable public mutating func removeLast() -> RecyclerView.OrderedDictionary<Key, Value>.Element {
    precondition(!isEmpty, "Cannot remove last element of an empty collection")
    return remove(at: count - 1)
  }
  @inlinable public mutating func removeLast(_ n: Swift.Int) {
    precondition(n >= 0, "Can't remove a negative number of elements")
    precondition(n <= count, "Can't remove more elements than there are in the collection")
    _keys.removeLast(n)
    _values.removeLast(n)
  }
  @discardableResult
  @inlinable public mutating func removeFirst() -> RecyclerView.OrderedDictionary<Key, Value>.Element {
    precondition(!isEmpty, "Cannot remove first element of an empty collection")
    return remove(at: 0)
  }
  @inlinable public mutating func removeFirst(_ n: Swift.Int) {
    precondition(n >= 0, "Can't remove a negative number of elements")
    precondition(n <= count, "Can't remove more elements than there are in the collection")
    _keys.removeFirst(n)
    _values.removeFirst(n)
  }
  @inlinable public mutating func removeAll(where shouldBeRemoved: (RecyclerView.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows {
    let pivot = try _values.withUnsafeMutableBufferPointer { values in
      try _keys._halfStablePartition(
        values: values,
        by: shouldBeRemoved)
    }
    removeSubrange(pivot...)
    _checkInvariants()
  }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol RecyclerViewDelegate<Identifier, Payload> : AnyObject {
  associatedtype Identifier : Swift.Hashable
  associatedtype Payload : Swift.Equatable
  func shouldHighlightItemWithIdentifier(_ identifier: Self.Identifier) -> Swift.Bool
  func shouldSelectItemWithIdentifier(_ identifier: Self.Identifier) -> Swift.Bool
  func shouldDeselectItemWithIdentifier(_ identifier: Self.Identifier) -> Swift.Bool
  func didSelectItemWithIdentifier(_ identifier: Self.Identifier)
  func didDeselectItemWithIdentifier(_ identifier: Self.Identifier)
}
#else
public protocol RecyclerViewDelegate : AnyObject {
  associatedtype Identifier : Swift.Hashable
  associatedtype Payload : Swift.Equatable
  func shouldHighlightItemWithIdentifier(_ identifier: Self.Identifier) -> Swift.Bool
  func shouldSelectItemWithIdentifier(_ identifier: Self.Identifier) -> Swift.Bool
  func shouldDeselectItemWithIdentifier(_ identifier: Self.Identifier) -> Swift.Bool
  func didSelectItemWithIdentifier(_ identifier: Self.Identifier)
  func didDeselectItemWithIdentifier(_ identifier: Self.Identifier)
}
#endif
extension RecyclerView.RecyclerViewDelegate {
  public func shouldHighlightItemWithIdentifier(_ identifier: Self.Identifier) -> Swift.Bool
  public func shouldSelectItemWithIdentifier(_ identifier: Self.Identifier) -> Swift.Bool
  public func shouldDeselectItemWithIdentifier(_ identifier: Self.Identifier) -> Swift.Bool
  public func didSelectItemWithIdentifier(_ identifier: Self.Identifier)
  public func didDeselectItemWithIdentifier(_ identifier: Self.Identifier)
}
extension CoreFoundation.CGPoint {
  public func offsetBy(dx: CoreFoundation.CGFloat, dy: CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
  public func offsetBy(_ point: CoreFoundation.CGPoint) -> CoreFoundation.CGPoint
  public func distanceSquared(to point: CoreFoundation.CGPoint) -> CoreFoundation.CGFloat
  public func distance(to point: CoreFoundation.CGPoint) -> CoreFoundation.CGFloat
}
extension Swift.RandomAccessCollection {
  @inlinable @inline(__always) internal func _index(at offset: Swift.Int) -> Self.Index {
    index(startIndex, offsetBy: offset)
  }
  @inlinable @inline(__always) internal func _offset(of index: Self.Index) -> Swift.Int {
    distance(from: startIndex, to: index)
  }
  @inlinable @inline(__always) internal subscript(_offset offset: Swift.Int) -> Self.Element {
    get {
    self[_index(at: offset)]
  }
  }
}
extension RecyclerView.OrderedSet : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RecyclerView.OrderedSet {
  @inline(__always) @inlinable public func _checkInvariants() {}
}
@frozen public struct OrderedSet<Element> where Element : Swift.Hashable {
  @usableFromInline
  internal typealias _Bucket = RecyclerView._HashTable.Bucket
  @usableFromInline
  internal var __storage: RecyclerView._HashTable.Storage?
  @usableFromInline
  internal var _elements: Swift.ContiguousArray<Element>
  @inlinable internal init(_uniqueElements: Swift.ContiguousArray<Element>, _ table: RecyclerView._HashTable?) {
    self.__storage = table?._storage
    self._elements = _uniqueElements
  }
  @inlinable @inline(__always) internal var _table: RecyclerView._HashTable? {
    get { __storage.map { _HashTable($0) } }
    set { __storage = newValue?._storage }
  }
}
extension RecyclerView.OrderedSet {
  @inlinable public var elements: [Element] {
    get {
      Array(_elements)
    }
    set {
      self = .init(newValue)
    }
    @inline(__always) _modify {
      var members = Array(_elements)
      _elements = []
      defer { self = .init(members) }
      yield &members
    }
  }
}
extension RecyclerView.OrderedSet {
  @inlinable internal var _capacity: Swift.Int {
    get {
    _table?.capacity ?? _HashTable.maximumUnhashedCount
  }
  }
  @inlinable internal var _minimumCapacity: Swift.Int {
    get {
    if _scale == _reservedScale { return 0 }
    return _HashTable.minimumCapacity(forScale: _scale)
  }
  }
  @inlinable internal var _scale: Swift.Int {
    get {
    _table?.scale ?? 0
  }
  }
  @inlinable internal var _reservedScale: Swift.Int {
    get {
    _table?.reservedScale ?? 0
  }
  }
  @inlinable internal var _bias: Swift.Int {
    get {
    _table?.bias ?? 0
  }
  }
}
extension RecyclerView.OrderedSet {
  @inlinable internal mutating func _regenerateHashTable(scale: Swift.Int, reservedScale: Swift.Int) {
    assert(_HashTable.maximumCapacity(forScale: scale) >= _elements.count)
    assert(reservedScale == 0 || reservedScale >= _HashTable.minimumScale)
    _table = _HashTable.create(
      uncheckedUniqueElements: _elements,
      scale: Swift.max(scale, reservedScale),
      reservedScale: reservedScale)
  }
  @inlinable internal mutating func _regenerateHashTable() {
    let reservedScale = _reservedScale
    guard
      _elements.count > _HashTable.maximumUnhashedCount || reservedScale != 0
    else {
      // We have too few elements; disable hashing.
      _table = nil
      return
    }
    let scale = _HashTable.scale(forCapacity: _elements.count)
    _regenerateHashTable(scale: scale, reservedScale: reservedScale)
  }
  @inlinable internal mutating func _regenerateExistingHashTable() {
    assert(_capacity >= _elements.count)
    guard _table != nil else {
      return
    }
    _ensureUnique()
    _table!.update { hashTable in
      hashTable.clear()
      hashTable.fill(uncheckedUniqueElements: _elements)
    }
  }
}
extension RecyclerView.OrderedSet {
  @inlinable @inline(__always) internal mutating func _isUnique() -> Swift.Bool {
    isKnownUniquelyReferenced(&__storage)
  }
  @inlinable internal mutating func _ensureUnique() {
    if __storage == nil { return }
    if isKnownUniquelyReferenced(&__storage) { return }
    _table = _table!.copy()
  }
}
extension RecyclerView.OrderedSet {
  @inlinable internal func _find(_ item: Element) -> (index: Swift.Int?, bucket: RecyclerView.OrderedSet<Element>._Bucket) {
    _find_inlined(item)
  }
  @inlinable @inline(__always) internal func _find_inlined(_ item: Element) -> (index: Swift.Int?, bucket: RecyclerView.OrderedSet<Element>._Bucket) {
    _elements.withUnsafeBufferPointer { elements in
      guard let table = _table else {
        return (elements.firstIndex(of: item), _Bucket(offset: 0))
      }
      return table.read { hashTable in
        hashTable._find(item, in: elements)
      }
    }
  }
  @inlinable internal func _bucket(for index: Swift.Int) -> RecyclerView.OrderedSet<Element>._Bucket {
    guard let table = _table else { return _Bucket(offset: 0) }
    return table.read { hashTable in
      var it = hashTable.bucketIterator(for: _elements[index])
      it.advance(until: index)
      precondition(it.isOccupied, "Corrupt hash table")
      return it.currentBucket
    }
  }
  @inlinable @inline(__always) public func firstIndex(of element: Element) -> Swift.Int? {
    _find(element).index
  }
  @inlinable @inline(__always) public func lastIndex(of element: Element) -> Swift.Int? {
    _find(element).index
  }
}
extension RecyclerView.OrderedSet {
  @inlinable @inline(never) internal __consuming func _extractSubset(using bitset: RecyclerView._UnsafeBitset, extraCapacity: Swift.Int = 0) -> RecyclerView.OrderedSet<Element> {
    assert(bitset.count == 0 || bitset.max()! <= count)
    if bitset.count == 0 { return Self(minimumCapacity: extraCapacity) }
    if bitset.count == self.count {
      if extraCapacity <= self._capacity - self.count {
        return self
      }
      var copy = self
      copy.reserveCapacity(count + extraCapacity)
      return copy
    }
    var result = Self(minimumCapacity: bitset.count + extraCapacity)
    for offset in bitset {
      result._appendNew(_elements[offset])
    }
    assert(result.count == bitset.count)
    return result
  }
}
extension RecyclerView.OrderedSet {
  @discardableResult
  @inlinable internal mutating func _removeExistingMember(at index: Swift.Int, in bucket: RecyclerView.OrderedSet<Element>._Bucket) -> Element {
    guard _elements.count - 1 >= _minimumCapacity else {
      let old = _elements.remove(at: index)
      _regenerateHashTable()
      return old
    }
    guard _table != nil else {
      return _elements.remove(at: index)
    }

    defer { _checkInvariants() }
    _ensureUnique()
    _table!.update { hashTable in
      // Delete the entry for the removed member.
      hashTable.delete(
        bucket: bucket,
        hashValueGenerator: { offset, seed in
          _elements[offset]._rawHashValue(seed: seed)
        })
      hashTable.adjustContents(preparingForRemovalOf: index, in: _elements)
    }
    return _elements.remove(at: index)
  }
}
extension RecyclerView.OrderedSet : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@usableFromInline
@frozen internal struct _HashTable {
  @usableFromInline
  internal var _storage: RecyclerView._HashTable.Storage
  @inlinable @inline(__always) internal init(_ storage: RecyclerView._HashTable.Storage) {
    _storage = storage
  }
}
extension RecyclerView._HashTable {
  @_inheritsConvenienceInitializers @usableFromInline
  final internal class Storage : Swift.ManagedBuffer<RecyclerView._HashTable.Header, Swift.UInt64> {
    @objc @usableFromInline
    deinit
  }
}
extension RecyclerView._HashTable {
  @usableFromInline
  @_effects(releasenone) internal init(scale: Swift.Int, reservedScale: Swift.Int = 0)
  @inlinable @inline(never) @_effects(releasenone) internal static func create<C>(uncheckedUniqueElements elements: C, scale: Swift.Int? = nil, reservedScale: Swift.Int = 0) -> RecyclerView._HashTable? where C : Swift.RandomAccessCollection, C.Element : Swift.Hashable {
    let minScale = Self.scale(forCapacity: elements.count)
    let scale = Swift.max(Swift.max(scale ?? 0, minScale),
                          reservedScale)
    if scale < Self.minimumScale { return nil }
    let hashTable = Self(scale: scale, reservedScale: reservedScale)
    hashTable.update { handle in
      handle.fill(uncheckedUniqueElements: elements)
    }
    return hashTable
  }
  @inlinable @inline(never) @_effects(releasenone) internal static func create<C>(untilFirstDuplicateIn elements: C, scale: Swift.Int? = nil, reservedScale: Swift.Int = 0) -> (hashTable: RecyclerView._HashTable?, end: C.Index) where C : Swift.RandomAccessCollection, C.Element : Swift.Hashable {
    let minScale = Self.scale(forCapacity: elements.count)
    let scale = Swift.max(Swift.max(scale ?? 0, minScale),
                          reservedScale)
    if scale < Self.minimumScale {
      // Don't hash anything.
      if elements.count < 2 { return (nil, elements.endIndex) }
      var temp: [C.Element] = []
      temp.reserveCapacity(elements.count)
      for i in elements.indices {
        let item = elements[i]
        guard !temp.contains(item) else { return (nil, i) }
        temp.append(item)
      }
      return (nil, elements.endIndex)
    }
    let hashTable = Self(scale: scale, reservedScale: reservedScale)
    let (_, index) = hashTable.update { handle in
      handle.fill(untilFirstDuplicateIn: elements)
    }
    return (hashTable, index)
  }
  @usableFromInline
  @_effects(releasenone) internal func copy() -> RecyclerView._HashTable
}
extension RecyclerView._HashTable {
  @inlinable @inline(__always) internal func read<R>(_ body: (RecyclerView._UnsafeHashTable) throws -> R) rethrows -> R {
    try _storage.withUnsafeMutablePointers { header, elements in
      let handle = _UnsafeHashTable(header: header, buckets: elements, readonly: true)
      return try body(handle)
    }
  }
  @inlinable @inline(__always) internal func update<R>(_ body: (RecyclerView._UnsafeHashTable) throws -> R) rethrows -> R {
    try _storage.withUnsafeMutablePointers { header, elements in
      let handle = _UnsafeHashTable(header: header, buckets: elements, readonly: false)
      return try body(handle)
    }
  }
}
extension RecyclerView._HashTable {
  @inlinable internal var header: RecyclerView._HashTable.Header {
    get { _storage.header }
    @inline(__always) nonmutating _modify { yield &_storage.header }
  }
  @inlinable internal var capacity: Swift.Int {
    get {
    _storage.header.capacity
  }
  }
  @inlinable internal var minimumCapacity: Swift.Int {
    get {
    if scale == reservedScale { return 0 }
    return Self.minimumCapacity(forScale: scale)
  }
  }
  @inlinable internal var scale: Swift.Int {
    get {
    _storage.header.scale
  }
  }
  @inlinable internal var reservedScale: Swift.Int {
    get {
    _storage.header.reservedScale
  }
  }
  @inlinable internal var bias: Swift.Int {
    get {
    _storage.header.bias
  }
  }
}
public protocol PositionSnapshotSupportingEngine : RecyclerView.RecyclerViewEngine {
  associatedtype Edge
  associatedtype PositionSnapshot
  func getPositionSnapshot(from edge: Self.Edge, in representation: any RecyclerView.ScrollViewRepresentation) -> Self.PositionSnapshot?
  func getOffsetForPositionSnapshot(_ positionSnapshot: Self.PositionSnapshot, in representation: any RecyclerView.ScrollViewRepresentation) -> CoreFoundation.CGPoint
  func prepareLayoutWithPositionSnapshot(positionSnapshot: Self.PositionSnapshot, animated: Swift.Bool, in representation: any RecyclerView.ScrollViewRepresentation)
  func commitLayoutSubviewsWithPositionSnapshot(positionSnapshot: Self.PositionSnapshot, animated: Swift.Bool, in representation: any RecyclerView.ScrollViewRepresentation)
}
extension CoreFoundation.CGRect {
  public var higherPoint: CoreFoundation.CGPoint {
    get
  }
  public var lowerPoint: CoreFoundation.CGPoint {
    get
  }
  public var centerPoint: CoreFoundation.CGPoint {
    get
  }
  @inline(__always) public mutating func offsettingBy(dx: CoreFoundation.CGFloat, dy: CoreFoundation.CGFloat)
}
public struct ViewConfiguration<View, Identifier, Payload> where View : UIKit.UIView, Identifier : Swift.Hashable, Payload : Swift.Equatable {
  public typealias Instantiation = (_ identifier: Identifier, _ payload: Payload, _ frame: CoreFoundation.CGRect) -> View
  public typealias Handler = (_ view: View, _ identifier: Identifier, _ payload: Payload) -> Swift.Void
  public init(instantiation: @escaping RecyclerView.ViewConfiguration<View, Identifier, Payload>.Instantiation = { _, _, rect in return View(frame: rect) }, propagation: @escaping RecyclerView.ViewConfiguration<View, Identifier, Payload>.Handler)
}
extension RecyclerView.OrderedSet : Swift.Sequence {
  public typealias Iterator = Swift.IndexingIterator<RecyclerView.OrderedSet<Element>>
  @inlinable public func _customContainsEquatableElement(_ element: Element) -> Swift.Bool? {
    _find(element).index != nil
  }
  @inlinable public __consuming func _copyToContiguousArray() -> Swift.ContiguousArray<Element> {
    _elements._copyToContiguousArray()
  }
  @inlinable public __consuming func _copyContents(initializing ptr: Swift.UnsafeMutableBufferPointer<Element>) -> (RecyclerView.OrderedSet<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index) {
    guard !isEmpty else { return (makeIterator(), 0) }
    let copied: Int = _elements.withUnsafeBufferPointer { buffer in
      guard let p = ptr.baseAddress else {
        preconditionFailure("Attempt to copy contents into nil buffer pointer")
      }
      let c = Swift.min(buffer.count, ptr.count)
      p.initialize(from: buffer.baseAddress!, count: c)
      return c
    }
    return (Iterator(_elements: self, _position: copied), copied)
  }
  @inlinable public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R? {
    try _elements.withContiguousStorageIfAvailable(body)
  }
}
extension RecyclerView.OrderedSet : Swift.RandomAccessCollection {
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  @inlinable @inline(__always) public var startIndex: Swift.Int {
    get { _elements.startIndex }
  }
  @inlinable @inline(__always) public var endIndex: Swift.Int {
    get { _elements.endIndex }
  }
  @inlinable @inline(__always) public var indices: RecyclerView.OrderedSet<Element>.Indices {
    get { _elements.indices }
  }
  @inlinable @inline(__always) public func index(after i: Swift.Int) -> Swift.Int { i + 1 }
  @inlinable @inline(__always) public func index(before i: Swift.Int) -> Swift.Int { i - 1 }
  @inlinable @inline(__always) public func formIndex(after i: inout Swift.Int) { i += 1 }
  @inlinable @inline(__always) public func formIndex(before i: inout Swift.Int) { i -= 1 }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int) -> Swift.Int {
    i + distance
  }
  @inlinable @inline(__always) public func index(_ i: Swift.Int, offsetBy distance: Swift.Int, limitedBy limit: Swift.Int) -> Swift.Int? {
    _elements.index(i, offsetBy: distance, limitedBy: limit)
  }
  @inlinable @inline(__always) public func distance(from start: Swift.Int, to end: Swift.Int) -> Swift.Int {
    end - start
  }
  @inlinable @inline(__always) public subscript(position: Swift.Int) -> Element {
    get {
    _elements[position]
  }
  }
  @inlinable public subscript(bounds: Swift.Range<Swift.Int>) -> RecyclerView.OrderedSet<Element>.SubSequence {
    get {
    _failEarlyRangeCheck(bounds, bounds: startIndex ..< endIndex)
    return SubSequence(_base: self, bounds: bounds)
  }
  }
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get { _elements.isEmpty }
  }
  @inlinable @inline(__always) public var count: Swift.Int {
    get { _elements.count }
  }
  @inlinable public func _customIndexOfEquatableElement(_ element: Element) -> Swift.Int?? {
    guard let table = _table else {
      return _elements._customIndexOfEquatableElement(element)
    }
    return table.read { hashTable in
      let (o, _) = hashTable._find(element, in: _elements)
      guard let offset = o else { return .some(nil) }
      return offset
    }
  }
  @inlinable @inline(__always) public func _customLastIndexOfEquatableElement(_ element: Element) -> Swift.Int?? {
    // OrderedSet holds unique elements.
    _customIndexOfEquatableElement(element)
  }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.Range<Swift.Int>) {
    _elements._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ index: Swift.Int, bounds: Swift.ClosedRange<Swift.Int>) {
    _elements._failEarlyRangeCheck(index, bounds: bounds)
  }
  @inlinable @inline(__always) public func _failEarlyRangeCheck(_ range: Swift.Range<Swift.Int>, bounds: Swift.Range<Swift.Int>) {
    _elements._failEarlyRangeCheck(range, bounds: bounds)
  }
}
public protocol InteractivelyMovingItemSupporting {
  var isInteractiveMovingPossible: Swift.Bool { get set }
  var isInteractiveMovingEnabled: Swift.Bool { get set }
}
final public class InteractivelyMovingItemSession<Identifier> {
  final public let identifier: Identifier
  final public let index: Swift.Int
  final public let inItemOffset: CoreFoundation.CGPoint
  unowned final public var gestureRecogniser: UIKit.UIGestureRecognizer {
    get
  }
  public init(identifier: Identifier, index: Swift.Int, inItemOffset: CoreFoundation.CGPoint, gestureRecogniser: UIKit.UIGestureRecognizer)
  @objc deinit
}
public protocol InteractiveReorderingSupportingEngine : RecyclerView.RecyclerViewEngine {
  func isInteractiveReorderingSessionPossible() -> Swift.Bool
  func startInteractiveReorderingSession(_ session: RecyclerView.InteractivelyMovingItemSession<Self.Identifier>)
  func finalizeInteractiveReorderingSession(_ session: RecyclerView.InteractivelyMovingItemSession<Self.Identifier>)
  func cancelInteractiveReorderingSession(_ session: RecyclerView.InteractivelyMovingItemSession<Self.Identifier>)
}
@_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class LongPressInteractiveMoveGestureRecogniser<Engine> : UIKit.UILongPressGestureRecognizer where Engine : RecyclerView.InteractiveReorderingSupportingEngine {
  @_Concurrency.MainActor(unsafe) public init(engine: Engine)
  @available(*, unavailable)
  @_Concurrency.MainActor(unsafe) @objc override required dynamic public init(target: Any?, action: ObjectiveC.Selector?)
  @_Concurrency.MainActor(unsafe) @objc override final public func ignore(_ touch: UIKit.UITouch, for event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func canPrevent(_ preventedGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func canBePrevented(by preventingGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func shouldRequireFailure(of otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func shouldBeRequiredToFail(by otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func shouldReceive(_ event: UIKit.UIEvent) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEstimatedPropertiesUpdated(_ touches: Swift.Set<UIKit.UITouch>)
  @_Concurrency.MainActor(unsafe) @objc override final public func reset()
  @objc deinit
}
extension RecyclerView._HashTable {
  @usableFromInline
  internal struct Header {
    @usableFromInline
    internal var _scaleAndSeed: Swift.UInt64
    @usableFromInline
    internal var _reservedScaleAndBias: Swift.UInt64
    @inlinable @inline(__always) internal var scale: Swift.Int {
      get { Int(_scaleAndSeed & 0x3F) }
    }
    @inlinable internal var reservedScale: Swift.Int {
      @inline(__always) get { Int(_reservedScaleAndBias & 0x3F) }
      set {
        assert(newValue >= 0 && newValue < 64)
        _reservedScaleAndBias &= ~0x3F
        _reservedScaleAndBias |= UInt64(truncatingIfNeeded: newValue) & 0x3F
      }
    }
    @inlinable @inline(__always) internal var seed: Swift.Int {
      get {
      Int(truncatingIfNeeded: _scaleAndSeed)
    }
    }
    @inlinable internal var bias: Swift.Int {
      @inline(__always) get { Int(truncatingIfNeeded: _reservedScaleAndBias) &>> 6 }
      set {
        let limit = (1 &<< scale) - 1
        var bias = newValue
        if bias < 0 { bias += limit }
        if bias >= limit { bias -= limit }
        assert(bias >= 0 && bias < limit)
        _reservedScaleAndBias &= 0x3F
        _reservedScaleAndBias |= UInt64(truncatingIfNeeded: bias) &<< 6
        assert(self.bias >= 0 && self.bias < limit)
      }
    }
    @inlinable @inline(__always) internal var capacity: Swift.Int {
      get { _HashTable.maximumCapacity(forScale: scale) }
    }
  }
}
public protocol SimpleLayoutSupporting {
  var isSticky: Swift.Bool { get }
  var spacing: CoreFoundation.CGFloat { get }
}
#if compiler(>=5.3) && $PrimaryAssociatedTypes2
public protocol SimpleLayoutEngineDelegate<Identifier> : AnyObject {
  associatedtype Identifier : Swift.Hashable
  func heightForView(_ view: UIKit.UIView, with identifier: Self.Identifier, width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat?
  func estimatedHeightForIdentifier(_ identifier: Self.Identifier) -> CoreFoundation.CGFloat?
}
#else
public protocol SimpleLayoutEngineDelegate : AnyObject {
  associatedtype Identifier : Swift.Hashable
  func heightForView(_ view: UIKit.UIView, with identifier: Self.Identifier, width: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat?
  func estimatedHeightForIdentifier(_ identifier: Self.Identifier) -> CoreFoundation.CGFloat?
}
#endif
extension RecyclerView.SimpleLayoutEngineDelegate {
  public func estimatedHeightForIdentifier(_ identifier: Self.Identifier) -> CoreFoundation.CGFloat?
}
public struct SimpleLayoutSettings : Swift.Equatable {
  public var additionalInsets: UIKit.UIEdgeInsets
  public var estimatedRowHeight: CoreFoundation.CGFloat
  public static func == (a: RecyclerView.SimpleLayoutSettings, b: RecyclerView.SimpleLayoutSettings) -> Swift.Bool
}
final public class SimpleLayoutEngine<Identifier, Payload> : RecyclerView.RecyclerViewEngine where Identifier : Swift.Hashable, Payload : RecyclerView.SimpleLayoutSupporting, Payload : Swift.Equatable {
  public typealias Identifier = Identifier
  public typealias Payload = Payload
  public typealias Item = RecyclerView.ItemModel<Identifier, Payload>
  weak final public var delegate: (any RecyclerView.SimpleLayoutEngineDelegate<Identifier>)?
  final public var contentSize: CoreFoundation.CGSize {
    get
  }
  final public var settings: RecyclerView.SimpleLayoutSettings {
    get
    set
  }
  final public var enableOppositeAnchor: Swift.Bool
  final public var identifiers: [Identifier] {
    get
  }
  public init(identifiers: [Identifier])
  final public func setup(_ coordinator: any RecyclerView.LayoutCoordinator<Identifier, Payload>, scrollView: RecyclerView.RecyclerScrollView<RecyclerView.SimpleLayoutEngine<Identifier, Payload>>)
  final public func targetContentOffset(forProposedContentOffset proposedContentOffset: CoreFoundation.CGPoint, withScrollingVelocity velocity: CoreFoundation.CGPoint) -> CoreFoundation.CGPoint
  final public func payloadForIdentifier(_ identifier: Identifier) -> Payload?
  final public func updatePayload(_ payload: Payload, forIdentifier identifier: Identifier)
  final public func prepare()
  final public func prepareLayoutSubviews()
  final public func commitLayoutSubviews()
  final public func beginLayoutIteration(invalidationCoordinator: any RecyclerView.InvalidationCoordinator<Identifier>)
  final public func finaliseLayoutIteration(invalidationCoordinator: any RecyclerView.InvalidationCoordinator<Identifier>)
  final public func identifiersVisibleIn(_ rect: CoreFoundation.CGRect) -> [Identifier]
  final public func identifierAtPoint(_ point: CoreFoundation.CGPoint) -> Identifier?
  final public func configurationForIdentifier(_ identifier: Identifier) -> RecyclerView.SimpleLayoutEngine<Identifier, Payload>.Configuration
  final public func preferredConfiguration(for cellContext: any RecyclerView.CellContext<Identifier>, invalidationCoordinator: any RecyclerView.InvalidationCoordinator<Identifier>) -> RecyclerView.SimpleLayoutEngine<Identifier, Payload>.Configuration
  final public func applyModifications(_ actionStorage: RecyclerView.ModificationActionsStorage<Identifier>, invalidationCoordinator: any RecyclerView.InvalidationCoordinator<Identifier>)
  final public func configurationForAppearingItem(with identifier: Identifier) -> RecyclerView.SimpleLayoutEngine<Identifier, Payload>.Configuration?
  final public func configurationDisappearingItem(with identifier: Identifier) -> RecyclerView.SimpleLayoutEngine<Identifier, Payload>.Configuration?
  @objc deinit
}
extension RecyclerView.SimpleLayoutEngine : RecyclerView.TapSelectionGestureSupportingEngine where Payload : RecyclerView.TapSelectionStateSupporting {
  final public func applyStateToCellWithIdentifier(_ identifier: Identifier, state: RecyclerView.TapSelectionState)
}
extension RecyclerView.SimpleLayoutEngine : RecyclerView.InteractiveReorderingSupportingEngine where Payload : RecyclerView.InteractivelyMovingItemSupporting {
  final public func isInteractiveReorderingSessionPossible() -> Swift.Bool
  final public func startInteractiveReorderingSession(_ session: RecyclerView.InteractivelyMovingItemSession<Identifier>)
  final public func finalizeInteractiveReorderingSession(_ session: RecyclerView.InteractivelyMovingItemSession<Identifier>)
  final public func cancelInteractiveReorderingSession(_ session: RecyclerView.InteractivelyMovingItemSession<Identifier>)
}
extension RecyclerView.SimpleLayoutEngine : RecyclerView.DropInteractionSupportingEngine {
  final public func startDropSession(_ session: any UIKit.UIDropSession)
  final public func updateDropSession(_ session: any UIKit.UIDropSession, locationInView: CoreFoundation.CGPoint, proposal: RecyclerView.RecyclerViewDropProposal)
  final public func performDrop(_ session: any UIKit.UIDropSession)
  final public func finishDropSession(_ session: any UIKit.UIDropSession)
}
extension RecyclerView.SimpleLayoutEngine : RecyclerView.PositionSnapshotSupportingEngine {
  final public func getPositionSnapshot(from edge: RecyclerView.SimpleLayoutEngine<Identifier, Payload>.PositionSnapshot.Edge, in representation: any RecyclerView.ScrollViewRepresentation) -> RecyclerView.SimpleLayoutEngine<Identifier, Payload>.PositionSnapshot?
  final public func getOffsetForPositionSnapshot(_ positionSnapshot: RecyclerView.SimpleLayoutEngine<Identifier, Payload>.PositionSnapshot, in representation: any RecyclerView.ScrollViewRepresentation) -> CoreFoundation.CGPoint
  final public func prepareLayoutWithPositionSnapshot(positionSnapshot: RecyclerView.SimpleLayoutEngine<Identifier, Payload>.PositionSnapshot, animated: Swift.Bool, in representation: any RecyclerView.ScrollViewRepresentation)
  final public func commitLayoutSubviewsWithPositionSnapshot(positionSnapshot: RecyclerView.SimpleLayoutEngine<Identifier, Payload>.PositionSnapshot, animated: Swift.Bool, in representation: any RecyclerView.ScrollViewRepresentation)
  public typealias Edge = RecyclerView.SimpleLayoutEngine<Identifier, Payload>.PositionSnapshot.Edge
}
extension RecyclerView.OrderedDictionary : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension UIKit.UIScrollView {
  @_Concurrency.MainActor(unsafe) public var minContentOffset: CoreFoundation.CGPoint {
    get
  }
  @_Concurrency.MainActor(unsafe) public var maxContentOffset: CoreFoundation.CGPoint {
    get
  }
  @_Concurrency.MainActor(unsafe) public var visibleRect: CoreFoundation.CGRect {
    get
  }
}
public struct Segment : Swift.Hashable {
  @inline(__always) public var origin: CoreFoundation.CGFloat
  @inline(__always) public var length: CoreFoundation.CGFloat {
    get
    set
  }
  public init(origin: CoreFoundation.CGFloat, length: CoreFoundation.CGFloat)
  public init(origin: Swift.Int, length: Swift.Int)
  public init(origin: CoreFoundation.CGFloat, length: Swift.Int)
  public init(origin: Swift.Int, length: CoreFoundation.CGFloat)
  @inlinable @inline(__always) public func contains(_ point: CoreFoundation.CGFloat) -> Swift.Bool {
        return point >= self.min && point < self.max
    }
  @inlinable @inline(__always) public func containsWithin(_ point: CoreFoundation.CGFloat) -> Swift.Bool {
        return point > self.min && point < self.max
    }
  @inlinable @inline(__always) public func intersects(_ segment: RecyclerView.Segment) -> Swift.Bool {
        return segment == self ||
            segment.min > self.min && segment.min < self.max ||
            segment.max > self.min && segment.max < self.max ||
            self.min > segment.min && self.min < segment.max ||
            self.max > segment.min && self.max < segment.max
    }
  @inlinable @inline(__always) public var isEmpty: Swift.Bool {
    get {
        length <= 0
    }
  }
  @inlinable @inline(__always) public var min: CoreFoundation.CGFloat {
    get {
        return origin
    }
  }
  @inlinable @inline(__always) public var mid: CoreFoundation.CGFloat {
    get {
        max - min / 2
    }
  }
  @inlinable @inline(__always) public var max: CoreFoundation.CGFloat {
    get {
        return origin + length
    }
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RecyclerView.Segment, b: RecyclerView.Segment) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RecyclerView.Segment : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RecyclerView.OrderedSet : Swift.Encodable where Element : Swift.Encodable {
  @inlinable public func encode(to encoder: any Swift.Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(_elements)
  }
}
extension RecyclerView.OrderedSet : Swift.Decodable where Element : Swift.Decodable {
  @inlinable public init(from decoder: any Swift.Decoder) throws {
    let container = try decoder.singleValueContainer()
    let elements = try container.decode(ContiguousArray<Element>.self)

    let (table, end) = _HashTable.create(untilFirstDuplicateIn: elements)
    guard end == elements.endIndex else {
      let context = DecodingError.Context(
        codingPath: container.codingPath,
        debugDescription: "Decoded elements aren't unique (first duplicate at offset \(end))")
      throw DecodingError.dataCorrupted(context)
    }
    self.init(
      _uniqueElements: elements,
      elements.count > _HashTable.maximumUnhashedCount ? table : nil)
  }
}
extension UIKit.UIEdgeInsets {
  public var totalHorizontalInset: CoreFoundation.CGFloat {
    get
  }
  public var totalVerticalInset: CoreFoundation.CGFloat {
    get
  }
}
extension RecyclerView._UnsafeBitset : Swift.Sendable {}
extension RecyclerView._UnsafeBitset.Iterator : Swift.Sendable {}
extension RecyclerView._UnsafeBitset.Word : Swift.Sendable {}
extension RecyclerView._HashTable.UnsafeHandle : Swift.Sendable {}
extension RecyclerView._HashTable.Bucket : Swift.Sendable {}
extension RecyclerView.LogType : Swift.Hashable {}
extension RecyclerView.SetActor.ExecutionType : Swift.Equatable {}
extension RecyclerView.SetActor.ExecutionType : Swift.Hashable {}
extension RecyclerView.ModificationActions.CaseType : Swift.Equatable {}
extension RecyclerView.ModificationActions.CaseType : Swift.Hashable {}
